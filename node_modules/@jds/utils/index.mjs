function cloneDeep(obj) {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (Array.isArray(obj)) {
    const newArray = [];
    for (let i = 0; i < obj.length; i++) {
      newArray[i] = cloneDeep(obj[i]);
    }
    return newArray;
  }
  const newObj = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      newObj[key] = cloneDeep(obj[key]);
    }
  }
  return newObj;
}
function each(collection, iteratee) {
  if (Array.isArray(collection)) {
    for (const item of collection) {
      iteratee(item);
    }
  } else {
    const keys = Object.keys(collection);
    for (const key of keys) {
      iteratee(collection[key], key);
    }
  }
}
const pickBy = (object, predicate) => {
  if (typeof predicate !== "function") {
    throw new TypeError("Predicate must be a function");
  }
  const result = {};
  for (const key in object) {
    if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key], key)) {
      result[key] = object[key];
    }
  }
  return result;
};
const omit = (obj, props) => {
  obj = { ...obj };
  props.forEach((prop) => delete obj[prop]);
  return obj;
};
const omitBy = (obj, check) => {
  obj = { ...obj };
  Object.entries(obj).forEach(([key, value]) => check(value, key) && delete obj[key]);
  return obj;
};
const get = (obj, path, defValue) => {
  if (!path)
    return void 0;
  const pathArray = Array.isArray(path) ? path : path.match(/([^[.\]])+/g);
  const result = pathArray?.reduce(
    (prevObj, key) => prevObj && prevObj[key],
    obj
  );
  return result === void 0 ? defValue : result;
};
const normalizeCapitalize = (str) => `${str.charAt(0).toUpperCase()}${str.slice(1).toLowerCase()}`;
const debounce = (fn, wait, immediate = false) => {
  let timeoutId;
  return function(...args) {
    const later = () => {
      timeoutId = null;
      if (!immediate)
        fn.apply(this, args);
    };
    const callNow = immediate && !timeoutId;
    timeoutId !== null && clearTimeout(timeoutId);
    timeoutId = setTimeout(later, wait);
    if (callNow)
      fn.apply(this, args);
  };
};
const removeBraces = (value) => value.replace(/[{}]/g, "");
const clamp = (value, min, max) => Math.max(min, Math.min(value, max));

function merge(base, ...rest) {
  let second;
  rest = rest.filter(Boolean);
  if (rest.length > 1) {
    const [first, ...others] = rest;
    second = merge(first, ...others);
  } else if (rest.length === 1) {
    second = rest[0];
  } else {
    return base;
  }
  return mergeObject(base, second);
}
function mergeObject(base, second) {
  const merged = {};
  const keys = [...Object.keys(base), ...Object.keys(second)];
  for (const key of keys) {
    if (!(key in second)) {
      merged[key] = base[key];
    } else if (!(key in base)) {
      merged[key] = second[key];
    } else {
      merged[key] = mergeValues(base[key], second[key]);
    }
  }
  return merged;
}
function mergeValues(base, second) {
  if (isObject(base) && isObject(second)) {
    return mergeObject(base, second);
  }
  return second;
}
function isObject(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
const capitalise = (s) => s?.replace(/./, (m) => m.toUpperCase());
const camelCase = (s, separator = "-") => s.split(separator).map((segment, index) => index === 0 ? segment : capitalise(segment)).join("");
const pascalCase = (s, separator = "-") => s.split(separator).map(capitalise).join("");
const kebabcase = (inputString) => inputString.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/([0-9])([a-zA-Z])/g, "$1-$2").replace(/([a-zA-Z])([0-9])/g, "$1-$2").replace(/\s+/g, "-").toLowerCase();
function hexToRGB(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16) / 255,
    g: parseInt(result[2], 16) / 255,
    b: parseInt(result[3], 16) / 255
  } : {
    r: 0,
    g: 0,
    b: 0
  };
}
function deepClone(obj) {
  return globalThis.structuredClone ? globalThis.structuredClone(obj) : JSON.parse(JSON.stringify(obj));
}
const snakeCase = (string) => {
  return string.replace(/\W+/g, " ").split(/ |\B(?=[A-Z])/).map((word) => word.toLowerCase()).join("_");
};

export { camelCase, capitalise, clamp, cloneDeep, debounce, deepClone, each, get, hexToRGB, kebabcase, merge, normalizeCapitalize, omit, omitBy, pascalCase, pickBy, removeBraces, snakeCase };
