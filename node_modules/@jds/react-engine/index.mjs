import { CSS_VAR_RULE_MAP, BrandStore, fetchTokenValue, withUnits, getCssVarFromToken, hasTokens, fetchTokenFromFolder, fetchTokenVariable, getDefaultProps, getInvariants, getLayersProps, drawComponent, getLayerClass, getLayerTestId } from '@jds/tokens-parser';
import { get, cloneDeep, pascalCase, pickBy, merge, removeBraces } from '@jds/utils';
import { getThemeColors } from '@jds/tokens';
import { jsx, Fragment, jsxs } from 'react/jsx-runtime';
import React, { useMemo, useState, useEffect, createContext, useRef, useContext, cloneElement, isValidElement, createElement, useCallback } from 'react';
import * as CoreIcons from '@jds/core-icons';
import { tokens } from '@jds/token-jio';
import { createPortal } from 'react-dom';

const index = '';

const themeKeys = [
  "primary",
  "secondary",
  "sparkle",
  "theme",
  "mode",
  "surface",
  "scale",
  "emphasis",
  "appearance",
  "strokeSurface",
  "accent"
];
let defaultTokenValues = {
  theme: "MyJio",
  mode: "light",
  scale: 25,
  density: "default",
  lang: "en",
  platform: "mobile",
  appearance: "neutral",
  surface: "default"
};
function setDefaultTokenValues(value) {
  defaultTokenValues = {
    ...defaultTokenValues,
    ...value,
    ...getThemeColors(value.theme || defaultTokenValues.theme)
  };
}
function getDefaultTokenValues() {
  return {
    ...defaultTokenValues,
    ...getThemeColors(defaultTokenValues.theme)
  };
}

const EVENTS_MAP = {
  onClick: "onClick",
  onFocus: "onFocus",
  onBlur: "onBlur",
  onHover: "onMouseEnter",
  onChange: "onChange",
  onHoverEnd: "onMouseLeave",
  onKeydown: "onKeyDown",
  onKeyup: "onKeyUp",
  onInvalid: "onInvalid",
  onLoad: "onLoad",
  onError: "onError",
  onPaste: "onPaste",
  onScroll: "onScroll",
  onSwipeLeft: [
    "onPointerDown",
    "onPointerMove",
    "onPointerUp",
    "onPointerOut",
    "onDragStart",
    "onDragEnd"
  ]
};
const filterInvalidValue = (v) => {
  if (typeof v === "undefined")
    return false;
  if (v === "")
    return false;
  if (v === null)
    return false;
  return true;
};
function getEventName(key) {
  const match = Object.keys(EVENTS_MAP).find((evt) => key === evt);
  const matchedEvent = EVENTS_MAP[match];
  return matchedEvent;
}
const internalLayerPrefixes = ["jds", "tooltip"];
const processConfigAPI = (config, values, layerProps) => {
  if (!values)
    return {};
  const finalData = {};
  Object.entries(config || {}).forEach(([name, item]) => {
    const resolvedConfigValues = item.values || [];
    if (!layerProps?.[name]) {
      if (!resolvedConfigValues.includes(values[name])) {
        if (filterInvalidValue(resolvedConfigValues[0]))
          finalData[name] = resolvedConfigValues[0];
      } else {
        if (filterInvalidValue(values[name]))
          finalData[name] = values[name];
      }
    }
  });
  return finalData;
};
const acceptedInternalProps = [
  "internalIndex",
  "layerRefs",
  "className",
  "internalClasses",
  "tabIndex",
  "slideIndex"
];
const processDataAPI = (api, currentLayer, values) => {
  if (!currentLayer)
    return {};
  const processData = {};
  const processChildren = {};
  const processedEvents = {};
  let processedA11y = {};
  const { data = {}, events, children = {} } = api;
  if (children[currentLayer]) {
    processChildren[currentLayer] = values[children[currentLayer].name];
  }
  const currentDataItem = data[currentLayer];
  Object.entries(currentDataItem || {}).forEach(
    ([name, { name: propName = "" }]) => {
      const currentName = propName.slice(
        propName.lastIndexOf(".") + 1,
        propName.length
      );
      const value = get(values, propName, void 0) || get(values, currentName, void 0);
      if (typeof value !== "undefined")
        processData[name] = value;
    }
  );
  if (events) {
    const currentEventItem = events[currentLayer];
    if (currentEventItem) {
      Object.entries(currentEventItem).forEach(([internalName, valueName]) => {
        const eventMapItem = getEventName(internalName);
        const resolvedName = typeof valueName === "string" ? valueName : valueName.name;
        if (!Array.isArray(eventMapItem)) {
          const baseLayer = getBaseLayerName(currentLayer);
          const key = baseLayer.startsWith("jds_") ? internalName : eventMapItem;
          if (!key)
            return;
          processedEvents[key] = values[resolvedName] || values[eventMapItem];
        } else {
          eventMapItem.forEach((item) => {
            if (item)
              processedEvents[item] = values[item];
          });
          if (internalName)
            processedEvents[internalName] = values[resolvedName];
        }
      });
    }
  }
  if (api.a11y) {
    processedA11y = processA11yData(api.a11y, currentLayer, values);
  }
  acceptedInternalProps.map((item) => {
    if (item in values)
      processData[item] = values[item];
  });
  return {
    processData,
    processedEvents,
    processedA11y,
    processedChildren: processChildren
  };
};
const processA11yData = (data, layer, api) => {
  if (!data[layer])
    return {};
  const { properties } = data[layer];
  if (!properties)
    return {};
  const processed = {};
  Object.entries(properties).forEach(([internalProperty, property]) => {
    if (typeof property === "string") {
      const normalisedProperty = property.slice(
        property.lastIndexOf(".") + 1,
        property.length
      );
      processed[internalProperty] = api[normalisedProperty];
    } else {
      const { name, value, prop } = property;
      const normalisedName = name?.slice(
        name.lastIndexOf(".") + 1,
        name.length
      );
      const defaultValue = api[prop || ""] || value;
      processed[internalProperty] = api[normalisedName] || defaultValue;
    }
  });
  return processed;
};
const validateProp = (prop) => {
  if (typeof prop === "undefined")
    return false;
  if (prop === null)
    return false;
  if (prop === "")
    return false;
  return true;
};
const mergeStyleProperties = (props, uiTokens, data, layerProps) => {
  const modifiedStyles = cloneDeep(uiTokens);
  Object.entries(data || {}).forEach(([layer, properties]) => {
    Object.entries(properties).forEach(([internalName, { name }]) => {
      modifiedStyles[layer] = modifiedStyles[layer] || {};
      if (validateProp(props[name])) {
        if (name in CSS_VAR_RULE_MAP) {
          if (!layerProps[layer] || !(name in layerProps[layer]) || themeKeys.includes(name)) {
            modifiedStyles[layer][name] = props[name];
          } else {
            delete modifiedStyles[layer][name];
          }
        } else {
          delete modifiedStyles[layer][name];
        }
        if (internalName in CSS_VAR_RULE_MAP) {
          if (!layerProps[layer] || !(internalName in layerProps[layer])) {
            modifiedStyles[layer][internalName] = props[name];
          } else {
            delete modifiedStyles[layer][internalName];
          }
        } else {
          delete modifiedStyles[layer][internalName];
        }
      }
    });
  });
  return modifiedStyles;
};
const allowedLayerProps = ["disabled", "transition"];
const seperateComponentLayerProps = (styles = {}, props) => {
  const layerProps = {};
  Object.entries(styles).forEach(([currentlayer, currentStyles]) => {
    const layerElements = currentlayer.split("-");
    const layerName = layerElements[layerElements.length - 1];
    if (!layerProps[currentlayer]) {
      layerProps[currentlayer] = {};
    }
    const isInternalLayer = internalLayerPrefixes.find(
      (i) => layerName.startsWith(i)
    );
    if (isInternalLayer) {
      Object.entries(currentStyles || {}).forEach(([property, value]) => {
        layerProps[currentlayer][property] = value;
      });
    }
    if (styles.value) {
      layerProps[currentlayer].value = currentStyles.value;
    }
    Object.entries(currentStyles).forEach(([property, value]) => {
      if (!(property in CSS_VAR_RULE_MAP)) {
        if (!(currentlayer in layerProps)) {
          layerProps[currentlayer] = {};
        }
        layerProps[currentlayer][property] = value;
      } else {
        if (allowedLayerProps.includes(property)) {
          layerProps[currentlayer][property] = value;
        }
      }
    });
  });
  return { layerProps, styles };
};
const BufferConverter = (value) => {
  return Buffer.from(value, "base64").toString("utf-8");
};
const convertBase64ToObject = (value) => {
  if (!value)
    return {};
  const converter = typeof window === "undefined" ? BufferConverter : window.atob;
  const objectString = converter(value);
  return JSON.parse(objectString || "{}");
};
const classNames = (...classes) => classes.filter(Boolean).join(" ");
const getCustomJSON = (custom) => {
  const base64 = custom.includes("--") ? (custom?.split("--") || [])[1] : custom;
  const convertedCustom = convertBase64ToObject(base64);
  return convertedCustom;
};
const getBaseLayerName = (layer = "") => {
  const parts = layer.split("-");
  return parts[parts.length - 1];
};
const clamp = (value, min, max) => Math.max(min, Math.min(value, max));

const AnimatedContainer = (props) => {
  return /* @__PURE__ */ jsx(
    "div",
    {
      style: props.style,
      className: classNames(props.className, "progress-animateContainer")
    }
  );
};

function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
  const angleInRadians = (angleInDegrees - 90) * Math.PI / 180;
  return {
    x: centerX + radius * Math.cos(angleInRadians),
    y: centerY + radius * Math.sin(angleInRadians)
  };
}
function describeArc(x, y, radius, startAngle, endAngle) {
  const start = polarToCartesian(x, y, radius, endAngle);
  const end = polarToCartesian(x, y, radius, startAngle);
  const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
  const d = [
    "M",
    start.x,
    start.y,
    "A",
    radius,
    radius,
    0,
    largeArcFlag,
    0,
    end.x,
    end.y
  ].join(" ");
  return d;
}
function getColorVariable(val, tokens = {}) {
  if (typeof val === "string") {
    if (val.match(/[{}]/)) {
      if (val.includes("&")) {
        tokens = BrandStore.updateFlatTokens({
          ...tokens,
          surface: val.split("_")[2].replace("}", "")
        });
      }
      return fetchTokenValue("color", val, tokens);
    }
  }
  return val.toString();
}
function getValue(val, rule, tokens = {}) {
  if (typeof val === "string") {
    if (val.match(/[{}]/)) {
      return fetchTokenValue(rule, val, tokens);
    }
  }
  return withUnits(rule, val);
}
const Arc = ({
  radius = 0,
  start = 0,
  end = 0,
  fill,
  className,
  arcWidth = 10,
  "animation-delay": animationDelay = "0ms",
  layer,
  animate,
  ...rest
}) => {
  start = parseInt(getValue(start, "rotate"), 10);
  end = parseInt(getValue(end, "rotate"), 10);
  radius = parseInt(getValue(radius, "width"), 10);
  arcWidth = parseInt(getValue(arcWidth, "width"), 10);
  animationDelay = getValue(animationDelay, "transition-delay");
  animationDelay = animationDelay.includes("ms") ? animationDelay : animationDelay + "ms";
  const strokeWidth = end - start === 0 ? 0 : arcWidth / 2;
  const diameter = radius * 2;
  const halfRadius = radius / 2;
  const circumference = 2 * Math.PI * halfRadius;
  const percent = end / 360 * 100;
  const dash = percent * circumference / 100;
  const midRadius = radius + strokeWidth;
  const durationKey = Object.keys(rest.style || {}).find(
    (key) => key.endsWith("transition-duration")
  );
  const variables = {
    "--diameter": diameter,
    "--rotate": `-${end}deg`,
    "--fill-color": getColorVariable(fill || "currentcolor", useTokenValues()),
    "--animation-delay": animationDelay,
    "--animation-duration": rest.style?.[durationKey] || (rest["animation-duration"] || 2.5) + "s",
    "--offset": animate ? "100px" : `${dash}px ${circumference - dash}px`,
    "--end": end * Math.PI / 180,
    "--start": start * Math.PI / 180,
    "--start-anim-offset": `${circumference}px`,
    "--end-anim-offset": `-${circumference}px`
  };
  const animateClass = animate ? "jds-spinner-circle-animate" : "";
  const arc = useMemo(() => {
    return describeArc(midRadius / 2, midRadius / 2, radius / 2, start, end);
  }, [start, end, midRadius]);
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: classNames(className, animateClass),
      style: {
        width: diameter,
        height: diameter,
        ...variables
      },
      children: /* @__PURE__ */ jsx(
        "svg",
        {
          className: classNames(
            "jds-spinner-circle",
            `circle-${layer}`,
            animate ? "animate" : ""
          ),
          viewBox: `0 0 ${radius + arcWidth / 2} ${radius + arcWidth / 2}`,
          children: Math.abs(end - start) === 360 || animate ? /* @__PURE__ */ jsx(
            "circle",
            {
              fill: "none",
              stroke: variables["--fill-color"],
              r: halfRadius,
              cx: midRadius / 2,
              cy: midRadius / 2,
              strokeWidth,
              strokeLinecap: "round"
            }
          ) : /* @__PURE__ */ jsx(
            "path",
            {
              d: arc,
              strokeLinecap: "round",
              className: classNames(animate ? "animated" : ""),
              strokeWidth,
              stroke: variables["--fill-color"],
              fill: "none",
              "data-dimension": `${end}-${start}-${end - start}`
            }
          )
        }
      )
    }
  );
};

const unsafeProps = [
  "height",
  "padding",
  "opacity",
  "translate-y",
  "translate-x",
  "max-height"
];
const Animated = (props) => {
  const [internalHidden, setInternalHidden] = useState(
    !props.animatedProperties?.length
  );
  useEffect(() => {
    if (!props.hidden) {
      setInternalHidden(false);
    }
  }, [props.hidden]);
  const hasProperties = unsafeProps.some(
    (property) => props.animatedProperties?.includes(property)
  );
  if (props.hidden) {
    if (!props.animatedProperties?.length)
      return null;
    if (!internalHidden) {
      if (!hasProperties)
        return null;
      return props.children || null;
    }
    if (hasProperties)
      return props.children;
    return null;
  }
  return React.cloneElement(props.children || /* @__PURE__ */ jsx(Fragment, {}), {
    onTransitionEnd: (ev) => {
      if (props.hidden) {
        setInternalHidden(true);
      }
    }
  });
};

const registeredIcons = { ...CoreIcons };
const registerIcons = (icons) => {
  Object.assign(registeredIcons, icons);
};
const availableIcons = (icons) => Object.keys(icons).filter((icon) => typeof icons[icon] === "function");
const useIcons = (ic) => {
  if (typeof ic === "string") {
    const NewIcon = registeredIcons[ic];
    if (!NewIcon)
      return null;
    return /* @__PURE__ */ jsx(NewIcon, {});
  }
  return ic;
};

const Icon = ({
  value,
  events,
  style,
  layer,
  className,
  role,
  _isLottieVisible,
  "aria-label": ariaLabel,
  "aria-describedby": ariaDescribedby,
  ...rest
}) => {
  const stringIcon = typeof value === "string";
  const camelCaseIcon = !stringIcon ? value : pascalCase(value || "", "_");
  const icon = useIcons(camelCaseIcon);
  if (!value)
    return null;
  return /* @__PURE__ */ jsx(
    Animated,
    {
      hidden: [true, "true"].includes(rest.hidden),
      animatedProperties: rest.transition?.property,
      children: React.isValidElement(icon) && React.cloneElement(icon, {
        "data-testid": rest?.["data-testid"] || "icon-root",
        className: classNames("icon-atom", className),
        ...events,
        style,
        "data-iconname": stringIcon ? value?.toLowerCase() : void 0,
        "data-hidden": rest.hidden,
        "data-transition": Boolean(rest.transition),
        role,
        "aria-label": ariaLabel,
        "aria-describedby": ariaDescribedby
      })
    }
  );
};

const Input = (props) => {
  const {
    disabled,
    className,
    children,
    type = "text",
    internalIndex,
    root,
    rootRef,
    textAlign,
    events = {},
    "aria-label": ariaLabel,
    "aria-describedby": ariaDescribedby,
    "aria-invalid": ariaInvalid,
    "aria-required": _ariaRequired,
    "aria-placeholder": _ariaPlaceholder,
    _childrenProps,
    processedA11y,
    textSize,
    layerRefs,
    isContainerFocusable,
    componentTag,
    ...rest
  } = props;
  const combinedStyles = {
    ...rest?.style,
    textAlign
  };
  const commonProps = {
    ...events,
    ...rest,
    style: combinedStyles,
    disabled,
    maxLength: rest["max-length"],
    value: rest.value
  };
  switch (type.toLowerCase()) {
    case "textarea":
      return /* @__PURE__ */ jsx("div", { className: "text-area-wrapper", children: /* @__PURE__ */ jsx(
        "textarea",
        {
          ref: layerRefs?.[rest.layer],
          ...commonProps,
          className: classNames(
            "jds-input-atom",
            className,
            "jds-textarea-atom"
          ),
          "aria-label": ariaLabel,
          "aria-describedby": ariaDescribedby,
          "aria-invalid": ariaInvalid,
          "aria-required": _ariaRequired,
          "aria-placeholder": _ariaPlaceholder
        }
      ) });
    case "phone":
      return /* @__PURE__ */ jsx(
        "input",
        {
          ...commonProps,
          value: commonProps.value ? String(commonProps.value).slice(0, commonProps["max-length"]) : props.value,
          maxLength: void 0,
          ref: layerRefs?.[rest.layer],
          type: "tel",
          className: classNames("jds-input-atom", className)
        }
      );
    default:
      return /* @__PURE__ */ jsx(
        "input",
        {
          ...commonProps,
          value: commonProps.value ? String(commonProps.value).slice(0, commonProps["max-length"]) : props.value,
          maxLength: void 0,
          type,
          ref: layerRefs?.[rest.layer],
          className: classNames("jds-input-atom", className),
          "aria-label": ariaLabel,
          "aria-describedby": ariaDescribedby,
          "aria-invalid": ariaInvalid,
          "aria-required": _ariaRequired,
          "aria-placeholder": _ariaPlaceholder
        }
      );
  }
};

const Loader = (props) => {
  return /* @__PURE__ */ jsx("div", { "data-testid": "loader-root", ...props, children: /* @__PURE__ */ jsx(Spinner, {}) });
};
const Spinner = () => {
  return /* @__PURE__ */ jsxs("div", { className: "j-spinner", children: [
    /* @__PURE__ */ jsx("svg", { className: "circle circle-0", viewBox: "0 0 28 28", children: /* @__PURE__ */ jsx(
      "circle",
      {
        "data-testid": "spinner-circle-icon",
        fill: "none",
        strokeWidth: "4",
        strokeLinecap: "round",
        cx: "14",
        cy: "14",
        r: "12"
      }
    ) }),
    /* @__PURE__ */ jsx("svg", { className: "circle circle-1", viewBox: "0 0 28 28", children: /* @__PURE__ */ jsx(
      "circle",
      {
        "data-testid": "spinner-circle-icon",
        fill: "none",
        strokeWidth: "4",
        strokeLinecap: "round",
        cx: "14",
        cy: "14",
        r: "12"
      }
    ) })
  ] });
};

const WINDOW = typeof window === "object" && window || void 0;
const defaultBreakpoints = {
  xmobile: 323,
  mobile: 619,
  tablet: 991,
  desktop: 992,
  widescreen: 1280,
  hd: 1920
};
class Devices {
  static withSizes(breakpoints) {
    this.breakpoints = Object.assign(this.breakpoints, breakpoints);
    return this;
  }
  /**
   * is width xmobile and below
   */
  static isXMobile() {
    const width = WINDOW?.innerWidth || 1e3;
    return width <= this.breakpoints.xmobile;
  }
  /**
   * is width mobile and below. returns true even on xmobile
   */
  static isMobile() {
    const width = WINDOW?.innerWidth || 1e3;
    return width <= this.breakpoints.mobile;
  }
  /**
   * is width above mobile and below desktop
   */
  static isTabletOnly() {
    const width = WINDOW?.innerWidth || 1e3;
    return width <= this.breakpoints.tablet && width > this.breakpoints.mobile;
  }
  /**
   * is width less than tablet? returns true even on mobile and xmobile
   */
  static isTablet() {
    const width = WINDOW?.innerWidth || 1e3;
    return width <= this.breakpoints.tablet;
  }
  /**
   * is width greater than tablet?
   */
  static isDesktop() {
    const width = WINDOW?.innerWidth || 1e3;
    return width >= this.breakpoints.tablet;
  }
  /**
   * is width greater than max-flex of desktop (1280px). i.e the breakpoint after which
   * max-width does not keep growing.
   */
  static isWidescreen() {
    const width = WINDOW?.innerWidth || 0;
    return width >= this.breakpoints.widescreen;
  }
  /**
   * is width greater than or equal to HD.
   */
  static isHD() {
    const width = WINDOW?.innerWidth || 0;
    return width >= this.breakpoints.hd;
  }
  /**
   * Re-renders functional component at Breakpoints from defaultBreakpoints.
   * @returns ```
   {
        xmobile: boolean,
        mobile: boolean,
        tablet: boolean,
        desktop: boolean,
        widescreen: boolean,
        hd: boolean
    }
   ```
   * [xmobile < mobile < tablet] [desktop > widescreen > HD]
   * tablet will be true even when xmobile and mobile are true.
   * desktop will be true even when widescreen and hd are true.
   *
   *
   * Breakpoints can be overridden by calling withSizes() first.
   * e.g. Devices.withSizes(mySize).useMedia()
   */
  static useMedia() {
    const queries = [
      `(max-width: ${this.breakpoints.xmobile}px)`,
      `(max-width: ${this.breakpoints.mobile}px)`,
      `(max-width: ${this.breakpoints.tablet}px)`,
      `(min-width: ${this.breakpoints.desktop}px)`,
      `(min-width: ${this.breakpoints.widescreen}px)`,
      `(min-width: ${this.breakpoints.hd}px)`
    ];
    const mediaQueryLists = queries.map(
      (q) => WINDOW?.matchMedia && WINDOW.matchMedia(q)
    );
    const getValue = () => {
      const matchedResults = mediaQueryLists.map((mql) => mql?.matches);
      const valObj = {
        xmobile: false,
        mobile: false,
        tablet: false,
        desktop: false,
        widescreen: false,
        hd: false
      };
      Object.keys(this.breakpoints).forEach((key, i) => {
        valObj[key] = matchedResults[i];
      });
      return valObj;
    };
    const [value, setValue] = useState(getValue);
    useEffect(
      () => {
        const handler = () => setValue(getValue);
        mediaQueryLists.forEach((mql) => mql?.addListener(handler));
        return () => mediaQueryLists.forEach((mql) => mql?.removeListener(handler));
      },
      []
      // Empty array ensures effect is only run on mount and unmount
    );
    return value;
  }
}
Devices.breakpoints = defaultBreakpoints;

const layersWithStyleAttr = ["button", "div"];
const filterUniqueTokens = (newTokens, existingTokens) => {
  if (newTokens._source === "popup") {
    return newTokens;
  }
  return pickBy(
    newTokens,
    (value, key) => !(key in existingTokens) || existingTokens[key] !== value
  );
};
const resolvePlatform = (exisintPlatform) => {
  const platform = Devices.useMedia();
  if (platform.desktop || platform.widescreen || platform.hd)
    return "desktop";
  if (platform.tablet)
    return "tablet";
  return "mobile";
};
const TokenContext = createContext({});
const registerBrandAndFetchTokenVars = (value, existingTokens, brandTokens) => {
  const defaultTokenValues = getDefaultTokenValues();
  let tokens$1 = {
    ...defaultTokenValues,
    ...existingTokens,
    parentAppearance: existingTokens.appearance,
    currentAppearance: value.appearance || "auto",
    surface: value.surface || "ghost",
    ...getThemeColors(
      value.theme || existingTokens.theme || defaultTokenValues.theme
    ),
    ...Object.fromEntries(
      Object.entries(value).filter(([_, v]) => v !== "auto")
    )
  };
  if (!tokens$1._registered || brandTokens) {
    BrandStore.registerBrand(brandTokens || tokens);
    tokens$1._registered = true;
  }
  if (BrandStore.updateFlatTokens) {
    tokens$1 = BrandStore.updateFlatTokens(tokens$1);
    tokens$1.parentScale = existingTokens.scale;
  }
  const equalThemeTokens = themeKeys.every(
    (key) => existingTokens[key] === value[key]
  );
  const entries = [];
  if (!(equalThemeTokens && !(value._source === "popup"))) {
    const mergedTokens = {
      ...defaultTokenValues,
      ...getThemeColors(existingTokens.theme || defaultTokenValues.theme),
      ...existingTokens
    };
    const uniqueTokens = filterUniqueTokens(tokens$1, mergedTokens);
    if (BrandStore.brandResolverFn) {
      if (["density"].some((item) => uniqueTokens[item])) {
        const densityMap = BrandStore.getDensityMap?.(tokens$1.density ?? "default") ?? {};
        entries.push(...Object.entries(densityMap));
      }
      if (["theme"].some((item) => uniqueTokens[item])) {
        const colorMap = BrandStore.getColorsMap({
          primary: tokens$1.primary,
          secondary: tokens$1.secondary,
          sparkle: tokens$1.sparkle
        });
        entries.push(...Object.entries(colorMap));
      }
    } else {
      const applicableTokens = BrandStore.getApplicableTokens(uniqueTokens);
      Object.entries(applicableTokens).forEach(
        ([folderKey, folder]) => Object.entries(folder).forEach(([key, value2]) => {
          entries.push([
            getCssVarFromToken(`${folderKey}-${key}`),
            hasTokens(value2) ? fetchTokenFromFolder(
              folderKey,
              value2,
              tokens$1
            ) : withUnits(folderKey, value2)
          ]);
        })
      );
    }
  }
  const styles = Object.fromEntries(entries);
  return { styles, tokens: tokens$1 };
};
const TokenProvider = ({
  value,
  children,
  tokens: brandTokens
}) => {
  const defaultTokenValues = getDefaultTokenValues();
  const rootRef = useRef();
  const timeoutRef = useRef();
  value ??= defaultTokenValues;
  const existingTokens = useContext(TokenContext);
  value.platform = resolvePlatform(value.platform || existingTokens.platform);
  const { styles, tokens } = useMemo(
    () => registerBrandAndFetchTokenVars(value, existingTokens, brandTokens),
    [value, brandTokens]
  );
  const isRootProvider = !Object.keys(existingTokens).length;
  useEffect(() => {
    function listener() {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
      timeoutRef.current = setTimeout(() => {
        const root = rootRef.current;
        if (root) {
          const { padding } = getComputedStyle(root);
          const base = parseFloat(padding);
          root.style.setProperty("--base", base.toString());
        }
      }, 100);
    }
    if (isRootProvider && tokens?.["brandVersion"] === "jio-v2") {
      window.addEventListener("resize", listener);
      listener();
    }
    return () => {
      if (isRootProvider && tokens?.["brandVersion"] === "jio-v2") {
        window.removeEventListener("resize", listener);
      }
    };
  }, [tokens?.["brandVersion"], isRootProvider]);
  if (!("brandVersion" in tokens) || tokens?.["brandVersion"] !== "jio-v2") {
    return /* @__PURE__ */ jsx("div", { style: { ...styles, display: "contents" }, className: "tokens", children: /* @__PURE__ */ jsx(TokenContext.Provider, { value: { ...tokens }, children }) });
  }
  if (isRootProvider) {
    return /* @__PURE__ */ jsx(
      "div",
      {
        className: "tokens-provider v3",
        style: {
          display: "contents",
          padding: "var(--pre-base)",
          ...tokens.maxWidth ? { "--viewport": tokens.maxWidth / 100 + "px" } : {},
          ...styles
        },
        ref: rootRef,
        children: /* @__PURE__ */ jsx(TokenContext.Provider, { value: { ...tokens }, children })
      }
    );
  }
  const newChildren = !Object.keys(styles).length ? children : React.Children.map(children, (child) => {
    if (React.isValidElement(child)) {
      if (layersWithStyleAttr.includes(
        typeof child.type === "string" ? child.type : child.type.name
      ) && !isRootProvider) {
        return React.cloneElement(child, {
          ...child.props,
          style: { ...child.props.style, ...styles }
        });
      }
      return /* @__PURE__ */ jsx(
        "div",
        {
          className: "tokens-provider",
          style: {
            ...styles,
            display: "contents"
          },
          children: child
        }
      );
    }
    return child;
  });
  return /* @__PURE__ */ jsx(TokenContext.Provider, { value: { ...tokens }, children: newChildren });
};
function useTokenValues() {
  const tokenValues = useContext(TokenContext);
  if (tokenValues === void 0) {
    throw new Error("useTokenValues must be used within a TokenProvider");
  }
  return tokenValues;
}
const useToken = (value, type) => {
  const tokens = useContext(TokenContext);
  if (tokens === void 0) {
    throw new Error("Please wrap your app in a TokenProvider");
  }
  return fetchTokenValue(type, value, tokens);
};

function CustomPortal({ children }) {
  const [mounted, setMounted] = useState(false);
  useEffect(() => {
    setMounted(true);
  }, []);
  return mounted && typeof window !== "undefined" ? createPortal(children, document.body) : null;
}

const Popup = ({
  children,
  className,
  style,
  events,
  rootRef,
  layer,
  ...rest
}) => {
  const { alignment = "top-start", priority } = rest;
  const x = rest.offsetX;
  const y = rest.offsetY;
  const left = alignment.includes("start") && x ? `${x}px` : void 0;
  const right = alignment.includes("end") && x ? `${x}px` : void 0;
  const top = alignment.includes("top") && y ? `${y}px` : void 0;
  const bottom = alignment.includes("bottom") && y ? `${y}px` : void 0;
  const styles = {
    backgroundColor: rest["background-color"],
    pointerEvents: rest.passive ? "none" : "auto",
    "--popup-priority": priority,
    "--popup-left": left,
    "--popup-right": right,
    "--popup-top": top,
    "--popup-bottom": bottom
  };
  const tokens = useTokenValues();
  if (tokens.fromPlugin)
    return children;
  return /* @__PURE__ */ jsx(CustomPortal, { children: /* @__PURE__ */ jsx(TokenProvider, { value: { ...tokens, _source: "popup" }, children: /* @__PURE__ */ jsx(
    Animated,
    {
      hidden: rest.hidden,
      animatedProperties: rest.transition?.property,
      children: /* @__PURE__ */ jsx(
        "div",
        {
          "data-testid": rest?.["data-testid"],
          ref: rootRef,
          style: {
            ...styles,
            ...style,
            pointerEvents: !rest.passive ? "auto" : "none",
            touchAction: events?.onClick || !rest.passive ? "auto" : "none"
          },
          className: classNames("jds-popup-layer", className),
          ...events,
          onClick: (ev) => {
            if (events?.onClick)
              ev.stopPropagation();
            events?.onClick?.(ev);
          },
          children
        }
      )
    }
  ) }) });
};

const SkeletonAnimatedLayer = ({
  layer,
  style,
  className,
  ...rest
}) => {
  return /* @__PURE__ */ jsx("div", { className: classNames("skeleton-animate-loader-container", className), children: /* @__PURE__ */ jsx("div", { "data-testid": rest["data-testid"], style }) });
};

const getTokenValue = (type, tokens, value) => {
  if (!value)
    return "";
  return fetchTokenVariable(type, value.toString() || "");
};
function getProgress(value = 0, min = 0, max = 100) {
  const offset = value - min;
  const range = max - min;
  const ratio = offset / range;
  const percentage = (1 - ratio) * 100;
  return Math.round(percentage);
}
function getSteppedValue(value, step = 1, min = 0, max = 100) {
  if (typeof value !== "number") {
    return min;
  }
  step = step > 0 ? step : 1;
  const clamped = clamp(value, min, max);
  return Math.round((clamped - min) / step) * step + min;
}
const Slider = ({
  min = 0,
  max = 100,
  "aria-label": ariaLabel,
  "aria-describedby": ariaDescribedby,
  "aria-valuenow": _ariaValuenow,
  "aria-valuemin": _ariaValuemin,
  "aria-valuemax": _ariaValuemax,
  ...props
}) => {
  const tokens = useTokenValues();
  const ballProperties = {
    "--ball-color": getTokenValue("color", tokens, props["ball-color"]),
    "--ball-color--active": getTokenValue(
      "color",
      tokens,
      props?.behavior.active["ball-color-active"]
    ),
    "--ball-color--hover": getTokenValue(
      "color",
      tokens,
      props?.behavior.hover["ball-color-active"]
    ),
    "--ball-size": getTokenValue("width", tokens, props["ball-size"]),
    "--ball-border-width": getTokenValue(
      "width",
      tokens,
      props["ball-border-width"]
    ),
    "--ball-border-color": getTokenValue(
      "color",
      tokens,
      props["ball-border-color"]
    ),
    "--active-color": getTokenValue("color", tokens, props["active-color"]),
    "--active-color--active": getTokenValue(
      "color",
      tokens,
      props?.behavior.active["active-color-active"]
    ),
    "--inactive-color": getTokenValue("color", tokens, props["inactive-color"])
  };
  const requiredValue = getSteppedValue(props.value, props.step, min, max) || 0;
  return /* @__PURE__ */ jsx(
    "input",
    {
      type: "range",
      step: props.step,
      value: requiredValue,
      min,
      max,
      size: 2,
      onChange: props.onChange,
      className: [props.className, "jds-slider-atom"].join(" "),
      "aria-label": ariaLabel,
      "aria-describedby": ariaDescribedby,
      "aria-valuenow": _ariaValuenow,
      "aria-valuemin": _ariaValuemin,
      "aria-valuemax": _ariaValuemax,
      style: {
        ...props.style,
        ...ballProperties,
        height: getTokenValue("height", tokens, props["track-height"]),
        "--progress": `${getProgress(requiredValue, min, max)}%`
      }
    }
  );
};

const alignClasses = {
  left: "text-left",
  center: "text-center",
  right: "text-right",
  justify: "text-justify"
};
const textAlignmentVariable = "--text-tx-al";
const Text = ({
  value,
  events: { onTextLayout, ...restEvents } = {},
  className,
  style,
  layer,
  textType = "div",
  role,
  "aria-describedby": ariaDescribedby,
  ...rest
}) => {
  if (typeof value === "undefined" || value === "")
    return null;
  const currentStyle = typeof style === "object" ? { ...style } : {};
  const Type = textType?.trim() === "" ? "div" : textType;
  const maxLines = Number(rest["max-lines"]) || 0;
  const maxLineClass = maxLines > 0 && "multi-line";
  const align = currentStyle[textAlignmentVariable];
  const alignClass = align ? alignClasses[align] ?? "" : "";
  currentStyle["--max-lines"] = maxLines || void 0;
  if (alignClass) {
    delete currentStyle[textAlignmentVariable];
  }
  return /* @__PURE__ */ jsx(
    Animated,
    {
      hidden: ["true", true].includes(rest.hidden),
      animatedProperties: rest.transition?.property,
      children: /* @__PURE__ */ jsx(
        Type,
        {
          className: classNames("text-atom", className, maxLineClass, alignClass),
          style: currentStyle,
          ...restEvents,
          "data-testid": rest["data-testid"],
          "aria-describedby": ariaDescribedby,
          role,
          children: value
        }
      )
    }
  );
};

const Textarea = (props) => {
  return /* @__PURE__ */ jsx("textarea", { ...props, className: "jds-input-textarea-atom" });
};

const VerticalTip = (props) => {
  const {
    processedA11y,
    isContainerFocusable,
    internalIndex,
    _childrenProps,
    svgClassName,
    ...svgProps
  } = props;
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: props.className,
      style: {
        boxSizing: "content-box",
        background: "transparent"
      },
      children: /* @__PURE__ */ jsx(
        "svg",
        {
          ...svgProps,
          className: svgClassName,
          width: "8",
          height: "24",
          viewBox: "0 0 8 24",
          fill: props["background-color"],
          xmlns: "http://www.w3.org/2000/svg",
          children: /* @__PURE__ */ jsx(
            "path",
            {
              id: "Vector 5",
              d: "M6.87661 14.4244L2.7121 18.1471C0.97557 19.6994 -9.59586e-08 21.8047 0 24L-1.04907e-06 -2.38419e-07C-9.53115e-07 2.19528 0.975566 4.30064 2.71209 5.85293L6.87661 9.57563C8.37446 10.9146 8.37446 13.0854 6.87661 14.4244Z"
            }
          )
        }
      )
    }
  );
};
const HorizontalTip = (props) => {
  const {
    processedA11y,
    isContainerFocusable,
    internalIndex,
    _childrenProps,
    svgClassName,
    ...svgProps
  } = props;
  return /* @__PURE__ */ jsx(
    "div",
    {
      className: props.className,
      style: {
        display: "flex",
        flexDirection: "column",
        background: "transparent"
      },
      children: /* @__PURE__ */ jsx(
        "svg",
        {
          ...svgProps,
          className: svgClassName,
          width: "24",
          height: "8",
          viewBox: "0 0 24 8",
          fill: props["background-color"],
          xmlns: "http://www.w3.org/2000/svg",
          children: /* @__PURE__ */ jsx(
            "path",
            {
              id: "Vector 5",
              d: "M14.4244 1.12338L18.1471 5.2879C19.6994 7.02443 21.8047 8 24 8L-2.38419e-07 8C2.19528 8 4.30064 7.02443 5.85294 5.28791L9.57564 1.12339C10.9146 -0.374462 13.0854 -0.374465 14.4244 1.12338Z"
            }
          )
        }
      )
    }
  );
};
const svgDirectionConfig = {
  vertical: VerticalTip,
  horizontal: HorizontalTip
};
const Tip = (props) => {
  const { position = "right", className } = props;
  const positionPrefix = position.split("_")?.[0].toLowerCase();
  const tipClass = `j_tooltip-tip-${positionPrefix}`;
  const direction = ["top", "bottom"].includes(positionPrefix) ? "horizontal" : "vertical";
  const Component = svgDirectionConfig[direction];
  return /* @__PURE__ */ jsx(Component, { ...props, className, svgClassName: tipClass });
};

const focusableSelectors = [
  'a[href]:not([tabindex^="-"])',
  'area[href]:not([tabindex^="-"])',
  'input:not([type="hidden"]):not([type="radio"]):not([disabled]):not([tabindex^="-"])',
  'input[type="radio"]:not([disabled]):not([tabindex^="-"])',
  'select:not([disabled]):not([tabindex^="-"])',
  'textarea:not([disabled]):not([tabindex^="-"])',
  'button:not([disabled]):not([tabindex^="-"])',
  'iframe:not([tabindex^="-"])',
  'audio[controls]:not([tabindex^="-"])',
  'video[controls]:not([tabindex^="-"])',
  '[contenteditable]:not([tabindex^="-"])',
  '[tabindex]:not([tabindex^="-"])'
];
const isVisible = (element) => {
  return element.offsetWidth || element.offsetHeight || element.getClientRects().length;
};
const getFocusableChildren = (root) => {
  if (!root)
    return null;
  const elements = [];
  root.querySelectorAll(focusableSelectors.join(",")).forEach((ele) => elements.push(ele));
  return elements.filter(isVisible);
};
const TrapFocus = (props) => {
  const ref = useRef(null);
  const { trap, children, ...rest } = props;
  const [lastFocus, setLastFocus] = useState(
    () => trap ? document.activeElement : null
  );
  useEffect(() => {
    return () => {
      lastFocus && lastFocus.focus?.();
    };
  }, []);
  const trapTabKey = (element, event) => {
    const focusableChildren = getFocusableChildren(element);
    if (!focusableChildren)
      return;
    const focusedItemIndex = document.activeElement ? focusableChildren.indexOf(document.activeElement) : -1;
    const lastIndex = focusableChildren.length - 1;
    const withShift = event.shiftKey;
    if (withShift && focusedItemIndex === 0) {
      focusableChildren?.[lastIndex]?.focus?.();
      event.preventDefault();
    } else if (!withShift && focusedItemIndex === lastIndex) {
      focusableChildren?.[0]?.focus?.();
      event.preventDefault();
    }
  };
  const moveFocusIn = () => {
    if (!getFocusableChildren(ref.current)?.includes(
      document?.activeElement
    )) {
      const target = ref?.current?.querySelector("[autofocus]") || getFocusableChildren(ref.current)?.[0];
      requestAnimationFrame(() => {
        target && target?.focus?.();
      });
    }
  };
  useEffect(() => {
    if (trap) {
      setLastFocus(document.activeElement);
      moveFocusIn();
    } else {
      lastFocus && lastFocus.focus?.();
    }
  }, [trap]);
  useEffect(() => {
    const handleKeyDown = (event) => {
      if (trap) {
        if (event.key === "Tab") {
          trapTabKey(ref?.current, event);
        }
      }
    };
    document.addEventListener("keydown", handleKeyDown, false);
    return () => {
      document.removeEventListener("keydown", handleKeyDown, false);
    };
  }, [ref, lastFocus, trap]);
  return /* @__PURE__ */ jsx("div", { style: { display: "contents" }, ref, ...rest, children });
};
TrapFocus.displayName = "TrapFocus";
TrapFocus.defaultProps = {
  trap: false
};

const filterInternalEvents = (events) => {
  const internalEvents = [
    "onSwipeLeft",
    "onSwipeRight",
    "onSwipeUp",
    "onSwipeDown",
    "onPinch",
    "onRotate",
    "onLongPress",
    "onDoubleTap"
  ];
  const filteredEvents = {};
  Object.entries(events).forEach(([key, handler]) => {
    if (!internalEvents.includes(key)) {
      filteredEvents[key] = handler;
    }
  });
  return filteredEvents;
};
const resolveDisabled = (disabled) => {
  if (typeof disabled === "object")
    return false;
  return disabled;
};
const disabledStyles = {
  cursor: "not-allowed",
  pointerEvents: "none",
  userSelect: "none"
};
const Container = (props) => {
  const {
    children,
    elementRef,
    events = {},
    className,
    style,
    disabled,
    passive,
    target,
    href,
    title,
    internalIndex,
    isContainerFocusable,
    root,
    rootRef,
    show,
    componentTag,
    ...rest
  } = props;
  const hasFocus = Boolean(isContainerFocusable && events?.onClick);
  const tokens = useTokenValues();
  const isJioV2 = tokens?.["brandVersion"] === "jio-v2";
  const isButton = className.includes("j-JDSButton-container") || className.includes("j-JDSButton2-container");
  const POINTER_CURSOR_CLASSES = [
    "j-JDSButton-container",
    "j-JDSLink-container",
    "j-JDSActionButton-inner-container",
    "j-JDSTabItem-container"
  ];
  const Element = String(componentTag) === "undefined" && String(props["web-tag"]) === "undefined" ? isButton ? "button" : "div" : props["web-tag"] || componentTag;
  if (!show && (!children || Array.isArray(children) && children.every((c) => c === null))) {
    return null;
  }
  const resolvedDisabled = resolveDisabled(disabled);
  const shouldHavePointerCursor = POINTER_CURSOR_CLASSES.some(
    (cls) => className?.includes(cls)
  );
  const filteredEvents = filterInternalEvents(events);
  return /* @__PURE__ */ jsx(
    Animated,
    {
      hidden: [true, "true"].includes(props.hidden),
      animatedProperties: rest.transition?.property,
      children: React.createElement(
        Element,
        {
          ...filteredEvents,
          type: rest.type,
          "data-testid": rest?.["data-testid"],
          "data-index": internalIndex,
          className: classNames(
            className,
            hasFocus ? "hasFocus" : "",
            hasFocus && isJioV2 ? "engine-container" : ""
          ),
          ref: elementRef || rootRef,
          disabled: resolvedDisabled,
          onKeyDown: (ev) => {
            if (document.activeElement === ev.target && ev.target.tagName !== "BUTTON") {
              if (ev.key === "Enter" || ev.key === " ") {
                const event = new MouseEvent("click", {
                  bubbles: true,
                  cancelable: true
                });
                ev.target.dispatchEvent(event);
              }
            }
            props.onKeyDown?.(ev);
          },
          title,
          style: {
            ...style,
            overflow: props["overflow"],
            touchAction: passive ? "none" : void 0,
            cursor: shouldHavePointerCursor ? "pointer" : events.onClick ? "default" : void 0,
            ...resolvedDisabled ? disabledStyles : void 0
          },
          tabIndex: props.tabIndex ?? (disabled ? -1 : hasFocus ? 0 : void 0),
          "aria-label": props["aria-label"],
          "aria-labelledby": props["aria-labelledby"],
          "aria-describedby": props["aria-describedby"],
          "aria-disabled": props["aria-disabled"],
          role: props.role,
          "aria-checked": props["aria-checked"],
          "aria-orientation": props["aria-orientation"],
          "aria-current": props["aria-current"],
          "aria-expanded": props["aria-expanded"],
          "aria-controls": props["aria-controls"],
          "aria-valuemin": props["aria-valuemin"],
          "aria-valuemax": props["aria-valuemax"],
          "aria-valuenow": props["aria-valuenow"],
          "aria-busy": props["aria-busy"],
          "aria-valuetext": props["aria-valuetext"],
          "aria-selected": props["aria-selected"],
          "aria-pressed": props["aria-pressed"],
          "aria-hidden": props["aria-hidden"],
          "aria-modal": props["aria-modal"],
          "aria-haspopup": props["aria-haspopup"],
          "aria-live": props["aria-live"]
        },
        children
      )
    }
  );
};

const Image = (props) => {
  const {
    value,
    semantics,
    events,
    internalIndex,
    processedA11y,
    imageFocus,
    aspectRatio,
    _childrenProps,
    _isLottieVisible,
    isContainerFocusable,
    roundedCorner,
    contentScale,
    ...props_
  } = props;
  const tokens = useTokenValues();
  const [src, setSrc] = useState(value);
  const handleError = () => {
    if (tokens?.["brandVersion"] === "jio-v2") {
      setSrc("https://picsum.photos/seed/picsum/200/300");
    }
  };
  const formatImageName = (imagePath = value || "") => {
    const parts = imagePath.split("/");
    const imageName = parts.length > 0 ? parts[parts.length - 1] : "";
    if (imageName) {
      const formattedName = imageName.replace(/\..*$/, "").replace(/([A-Z])/g, " $1").toLowerCase() + " image";
      return formattedName;
    }
    return "Image name not found";
  };
  return /* @__PURE__ */ jsx(
    "img",
    {
      "data-testid": "image-root",
      alt: semantics || formatImageName(src),
      src,
      onError: handleError,
      ...props_,
      ...events,
      style: {
        ...props_.style,
        width: tokens?.["brandVersion"] === "jio-v2" ? props_.width : "100%",
        opacity: !value ? 0 : void 0
      }
    }
  );
};

const Link = (props) => {
  const { children, events, className, style, layer, ...rest } = props;
  return /* @__PURE__ */ jsx(
    "a",
    {
      ...events,
      className,
      style,
      "data-testid": rest?.["data-testid"],
      children: React.Children.map(props.children, (item) => item && cloneElement(item))
    }
  );
};

const PromoCardArc = (props) => {
  const { orientation, style, className } = props;
  if (orientation === "horizontal") {
    return /* @__PURE__ */ jsx(
      "svg",
      {
        className,
        viewBox: "0 0 1 1",
        xmlns: "http://www.w3.org/2000/svg",
        style: { display: "block", ...style },
        children: /* @__PURE__ */ jsx("path", { d: "M0,0 L0,5 C1,3 1,-3 0,-5 L0,0", fill: "currentcolor" })
      }
    );
  }
  return /* @__PURE__ */ jsx(
    "svg",
    {
      className,
      viewBox: "0 0 1 1",
      xmlns: "http://www.w3.org/2000/svg",
      style: { display: "block", ...style },
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M0,0 L0,10 C1,3 1,-3 0,-10 L0,0",
          fill: "currentcolor",
          style: {
            transform: "rotate(270deg) translateX(-100%) translateY(50%"
          }
        }
      )
    }
  );
};

const addV2TagToCompLayer = (tokens, layer) => {
  if (!layer)
    return layer;
  if (tokens?.["brandVersion"] === "jio-v2") {
    if (!layer.endsWith("2")) {
      return layer + "2";
    }
  }
  return layer;
};
const RenderComponent = (Comp, props, componentsMap) => {
  const tokens = useTokenValues();
  const comp = addV2TagToCompLayer(tokens, Comp?.component);
  if (comp && componentsMap?.[comp]) {
    Comp = createElement(componentsMap?.[comp](), Comp.props);
  }
  if (Array.isArray(Comp)) {
    return Comp.map((C) => {
      if (!C.component)
        return RenderComponent(C, { ...C.props, ...props }, componentsMap);
      const comp2 = addV2TagToCompLayer(tokens, C?.component);
      return RenderComponent(comp2, { ...C.props, ...props }, componentsMap);
    });
  }
  if (!isValidElement(Comp)) {
    return null;
  }
  const compName = getComponentName(Comp);
  const { slot_layers, ...newProps } = props ?? {};
  const { lock_all, ...slotProps } = slot_layers?.[compName] ?? slot_layers?.[compName + "2"] ?? {};
  for (const prop in slotProps) {
    const arr = [].concat(slotProps[prop]);
    const value = Comp.props[prop];
    if (arr.includes(value)) {
      newProps[prop] = value;
    } else {
      newProps[prop] = arr[0];
      value !== void 0 && console.warn(
        `Invalid property on ${compName} for ${prop} - currently ${value}. Value must be one of [${arr.join()}]`
      );
    }
  }
  if (lock_all) {
    return createElement(Comp.type, { ...Comp.props, ...newProps });
  }
  return cloneElement(Comp, { ...Comp.props, ...newProps });
};
const removeBrandPrefixes = (name) => {
  const PREFIXES = ["jds_"];
  let currentName = name;
  PREFIXES.forEach((prefix) => {
    currentName = currentName.replace(prefix, "");
  });
  return currentName;
};
const getComponentName = (Comp) => {
  if (!Comp)
    return "";
  if (Comp?.type?.slotName)
    return Comp?.type?.slotName?.replace(/\d+$/, "");
  if (Comp?.slotName)
    return Comp?.slotName?.replace(/\d+$/, "");
  return Comp?.type?.displayName ?? Comp?.displayName ?? "";
};
const Slot = ({
  _childrenProps,
  layer,
  events,
  className,
  style = {},
  disabled,
  slot_layers,
  ...rest
}) => {
  const { api: children, props } = _childrenProps;
  if (!children?.[layer]?.name)
    return null;
  const Comp = props?.[children?.[layer]?.name];
  if (!Comp)
    return null;
  const hasStyle = Boolean(Object.keys(style || {}).length);
  const _accepts = children?.[layer]?.accepts.map(
    (item) => item.replace(/\d+$/, "")
  );
  const acceptedArrayItems = [];
  _accepts?.forEach((item) => {
    if (typeof item === "string") {
      acceptedArrayItems.push(
        removeBrandPrefixes(item.toLowerCase()).replace(/\d+$/, "")
      );
    }
    if (Array.isArray(item))
      item.map(
        (item2) => acceptedArrayItems.push(
          removeBrandPrefixes(item2?.toLowerCase()).replace(/\d+$/, "")
        )
      );
    return acceptedArrayItems;
  });
  const shouldComponentRender = (Comp2) => {
    if (Comp2.component) {
      Comp2 = RenderComponent(
        Comp2,
        Comp2.props,
        _childrenProps?.componentsMap || {}
      );
    }
    const CompName = getComponentName(Comp2);
    const should = acceptedArrayItems.includes(CompName?.toLowerCase()) || _accepts.includes(CompName?.toLowerCase().replace(/\d+$/, "")) || ["any", "template", "Any"].includes(_accepts[0]);
    if (!should) {
      console.warn("Did not render", {
        Comp: Comp2,
        CompName,
        acceptedArrayItems,
        _accepts
      });
    }
    return should;
  };
  const isReactElement = (obj) => obj?.$$typeof === Symbol.for("react.element");
  const isArrayOfReactElements = (obj) => Array.isArray(obj) && obj.every(isReactElement);
  if (!isReactElement(Comp) && !isArrayOfReactElements(Comp)) {
    console.warn("not a react element", Comp);
  }
  if (Comp.type !== Symbol.for("react.fragment") && isValidElement(Comp)) {
    if (shouldComponentRender(Comp)) {
      if (!hasStyle)
        return RenderComponent(
          Comp,
          {
            ...events,
            ...Comp.props,
            style: { ...rest["style"], ...Comp?.props?.style },
            slot_layers
          },
          _childrenProps?.componentsMap || {}
        );
      return /* @__PURE__ */ jsx(
        "div",
        {
          className,
          style: {
            ...style,
            display: "contents",
            pointerEvents: disabled ? "none" : void 0
          },
          children: RenderComponent(
            Comp,
            {
              ...events,
              ...Comp.props,
              style: { ...rest["style"], ...Comp?.props?.style },
              slot_layers
            },
            _childrenProps?.componentsMap || {}
          )
        }
      );
    }
  }
  if (Array.isArray(Comp)) {
    if (children?.[layer]?.max) {
      if (!hasStyle)
        return /* @__PURE__ */ jsx(Fragment, { children: Comp.slice(0, children?.[layer]?.max).filter(shouldComponentRender).map(
          (Item, i) => RenderComponent(
            Item,
            {
              key: getComponentName(Item) + i,
              ...events,
              slot_layers
            },
            _childrenProps?.componentsMap || {}
          )
        ) });
      return /* @__PURE__ */ jsx(
        "div",
        {
          className,
          style: {
            ...style,
            display: "contents",
            pointerEvents: disabled ? "none" : void 0
          },
          children: Comp.slice(0, children?.[layer]?.max).filter(shouldComponentRender).map(
            (Item, i) => RenderComponent(
              Item,
              {
                key: getComponentName(Item) + i,
                ...events,
                slot_layers
              },
              _childrenProps?.componentsMap || {}
            )
          )
        }
      );
    }
    if (!hasStyle)
      return /* @__PURE__ */ jsx(Fragment, { children: Comp.filter(shouldComponentRender).map(
        (Item, i) => RenderComponent(
          Item,
          {
            key: getComponentName(Item) + i,
            ...events,
            slot_layers
          },
          _childrenProps?.componentsMap || {}
        )
      ) });
    return /* @__PURE__ */ jsx(
      "div",
      {
        className,
        style: {
          ...style,
          display: "contents",
          pointerEvents: disabled ? "none" : void 0
        },
        children: Comp.filter(shouldComponentRender).map(
          (Item, i) => RenderComponent(
            Item,
            {
              key: getComponentName(Item) + i,
              ...events,
              slot_layers
            },
            _childrenProps?.componentsMap || {}
          )
        )
      }
    );
  }
  const renderFragment = (Comp2) => {
    let ComponentChildren;
    if (children?.[layer]?.max || Array.isArray(Comp2.props.children)) {
      ComponentChildren = Comp2.props.children.slice?.(0, children?.[layer]?.max).map((item) => {
        if (item?.type === Symbol.for("react.fragment")) {
          return renderFragment(item);
        } else if (item) {
          return shouldComponentRender(item) && RenderComponent(
            item,
            { ...item.props, slot_layers },
            _childrenProps?.componentsMap || {}
          );
        }
        return null;
      });
      if (!hasStyle)
        return ComponentChildren;
      return /* @__PURE__ */ jsx(
        "div",
        {
          className,
          style: {
            ...style,
            display: "contents",
            pointerEvents: disabled ? "none" : void 0
          },
          children: ComponentChildren.map(
            (child) => shouldComponentRender(child) && RenderComponent(
              child,
              { ...child.props, slot_layers },
              _childrenProps?.componentsMap || {}
            )
          )
        }
      );
    }
    ComponentChildren = Comp2.props.children;
    return ComponentChildren.map(
      (child) => shouldComponentRender(child) && RenderComponent(
        child,
        { ...child.props, slot_layers },
        _childrenProps?.componentsMap || {}
      )
    );
  };
  if (typeof Comp === "object" && Comp.type === Symbol.for("react.fragment")) {
    return renderFragment(Comp);
  }
  return null;
};

const ButtonVector = (props) => {
  const transformAngle = props.direction !== "reversed" ? 180 : 0;
  const borderClass = props["border-type"] === "solid" ? "solid-border" : "none";
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      className: classNames(props.className, borderClass, "sw-btn-vector"),
      style: {
        ...props.style,
        transform: `rotate(${transformAngle}deg)`
      },
      preserveAspectRatio: "none",
      viewBox: "0 0 40 56",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [
        /* @__PURE__ */ jsx("mask", { id: "path-1-inside-1_23_23", fill: "red", children: /* @__PURE__ */ jsx("path", { d: "M0 56H12.53C12.53 56 24.19 55.81 28.54 41.98C32.44 30.4 37.86 28.35 40 28C37.86 27.64 32.45 25.6 28.54 14.02C24.19 0.190001 12.53 0 12.53 0H0" }) }),
        /* @__PURE__ */ jsx(
          "path",
          {
            className: "inside",
            d: "M0 56H12.53C12.53 56 24.19 55.81 28.54 41.98C32.44 30.4 37.86 28.35 40 28C37.86 27.64 32.45 25.6 28.54 14.02C24.19 0.190001 12.53 0 12.53 0H0",
            fill: "currentcolor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.53 56V57H12.5381L12.5463 56.9999L12.53 56ZM28.54 41.98L27.5923 41.6608L27.5891 41.6704L27.5861 41.68L28.54 41.98ZM40 28L40.1614 28.9869L40.1659 27.0139L40 28ZM28.54 14.02L27.5861 14.32L27.5892 14.33L27.5926 14.3399L28.54 14.02ZM12.53 0L12.5463 -0.999867L12.5381 -1H12.53V0ZM0 57H12.53V55H0V57ZM12.53 56C12.5463 56.9999 12.5469 56.9999 12.5476 56.9998C12.5479 56.9998 12.5486 56.9998 12.5491 56.9998C12.5503 56.9998 12.5516 56.9998 12.5531 56.9997C12.556 56.9997 12.5597 56.9996 12.5641 56.9995C12.5729 56.9993 12.5844 56.9989 12.5988 56.9984C12.6274 56.9974 12.6671 56.9957 12.7171 56.993C12.8171 56.9875 12.9588 56.9776 13.1374 56.96C13.4946 56.9249 14.0005 56.8588 14.6173 56.7345C15.8497 56.4863 17.5338 56.004 19.3606 55.0658C23.038 53.1773 27.2325 49.47 29.4939 42.28L27.5861 41.68C25.4975 48.32 21.687 51.6227 18.4469 53.2867C16.815 54.1248 15.3121 54.5544 14.2224 54.7739C13.6781 54.8836 13.2391 54.9404 12.9416 54.9696C12.7929 54.9843 12.6799 54.992 12.6069 54.996C12.5705 54.998 12.5441 54.9991 12.5284 54.9997C12.5205 54.9999 12.5153 55.0001 12.5128 55.0001C12.5116 55.0002 12.5111 55.0002 12.5112 55.0002C12.5113 55.0002 12.5115 55.0002 12.5119 55.0002C12.5121 55.0002 12.5126 55.0002 12.5127 55.0001C12.5132 55.0001 12.5137 55.0001 12.53 56ZM29.4877 42.2992C33.2983 30.9845 38.4683 29.2638 40.1614 28.9869L39.8386 27.0131C37.2517 27.4362 31.5817 29.8155 27.5923 41.6608L29.4877 42.2992ZM40.1659 27.0139C38.4677 26.7282 33.3074 25.0135 29.4874 13.7001L27.5926 14.3399C31.5926 26.1865 37.2523 28.5518 39.8341 28.9861L40.1659 27.0139ZM29.4939 13.72C27.2325 6.53004 23.038 2.82274 19.3606 0.934197C17.5338 -0.00395302 15.8497 -0.486254 14.6173 -0.734524C14.0005 -0.858788 13.4946 -0.924878 13.1374 -0.960018C12.9588 -0.977597 12.8171 -0.987457 12.7171 -0.992973C12.6671 -0.995731 12.6274 -0.997405 12.5988 -0.998413C12.5844 -0.998918 12.5729 -0.999256 12.5641 -0.999481C12.5597 -0.999594 12.556 -0.999678 12.5531 -0.99974C12.5516 -0.999771 12.5503 -0.999796 12.5491 -0.999817C12.5486 -0.999828 12.5479 -0.999841 12.5476 -0.999846C12.5469 -0.999857 12.5463 -0.999867 12.53 0C12.5137 0.999867 12.5132 0.999858 12.5127 0.99985C12.5126 0.999848 12.5121 0.99984 12.5119 0.999836C12.5115 0.999829 12.5113 0.999824 12.5112 0.999822C12.5111 0.999819 12.5116 0.99983 12.5128 0.999862C12.5153 0.999925 12.5205 1.00007 12.5284 1.00035C12.5441 1.0009 12.5705 1.00198 12.6069 1.00399C12.6799 1.00801 12.7929 1.01574 12.9416 1.03037C13.2391 1.05964 13.6781 1.11644 14.2224 1.22609C15.3121 1.44563 16.815 1.8752 18.4469 2.7133C21.687 4.37726 25.4975 7.67996 27.5861 14.32L29.4939 13.72ZM12.53 -1H0V1H12.53V-1Z",
            fill: "url(#paint0_angular_23_23)",
            mask: "url(#path-1-inside-1_23_23)"
          }
        ),
        props["border-type"] === "gradient" && /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsxs(
          "radialGradient",
          {
            id: "paint0_angular_23_23",
            cx: "0",
            cy: "0",
            r: "1",
            gradientUnits: "userSpaceOnUse",
            gradientTransform: "translate(38.5 51.5) rotate(154.464) scale(70.402 85.8467)",
            children: [
              /* @__PURE__ */ jsx("stop", { offset: "0.0165174", stopColor: "#EAB872" }),
              /* @__PURE__ */ jsx("stop", { offset: "0.280935", stopColor: "#63371D" }),
              /* @__PURE__ */ jsx("stop", { offset: "0.563131", stopColor: "#FFEAC2" }),
              /* @__PURE__ */ jsx("stop", { offset: "0.796371", stopColor: "#AE824E" })
            ]
          }
        ) })
      ]
    }
  );
};

const atomsMap = {
  container: Container,
  text: Text,
  icon: Icon,
  image: Image,
  slider: Slider,
  animatedContainer: AnimatedContainer,
  loader: Loader,
  link: Link,
  popup: Popup,
  textarea: Textarea,
  tooltip: Tip,
  input: Input,
  promoCardArc: PromoCardArc,
  arc: Arc,
  slot: Slot,
  skeletonLoader: SkeletonAnimatedLayer,
  button_vector: ButtonVector
};
const isAtomic = (layer) => {
  const baseLayerName = getBaseLayerName(layer);
  return Object.keys(atomsMap).includes(baseLayerName);
};

const createComponent = (componentProperties, props, componentName = "component", componentsMap, _custom = {}, parentRuntime) => {
  const runtime = parentRuntime || props.runtime;
  const { hierarchy, api, ...rest } = componentProperties;
  const { componentTag, ...restProps } = props;
  const customMergedJSON = merge({ api, ...rest }, _custom);
  const defaultProps = getDefaultProps(customMergedJSON.api);
  const invariants = getInvariants(customMergedJSON);
  const normalisedProperties = processConfigAPI(api?.config, props);
  const mergedProps = { ...restProps, ...normalisedProperties };
  const flatTokens = useTokenValues();
  const propTokens = pickBy(
    mergedProps,
    (v, k) => themeKeys.includes(k) && v !== "auto"
  );
  const getPercentageTokens = Object.keys(defaultProps).filter(
    (key) => props[key] !== defaultProps[key]
  );
  const defaultSwitchables = getDefaultTokenValues();
  const hasDifferentTokens = Object.keys(pickBy(propTokens, (v, k) => v !== defaultSwitchables[k])).length > 0;
  const shouldIncludeAmpersand = getPercentageTokens.length > 0 && hasDifferentTokens || Object.values(customMergedJSON.base).some(
    (item) => Object.keys(item).some((key) => key.endsWith("color") || key === "fill")
  );
  const config = BrandStore.brandResolverFn && !runtime ? {
    getAmpersandTokens: shouldIncludeAmpersand,
    getPercentageTokens,
    getAllBaseLayers: false,
    transformer: false
  } : void 0;
  const uiTokens = getLayersProps(
    mergedProps,
    cloneDeep(customMergedJSON),
    config
  );
  const { layerProps, styles: styles_ } = seperateComponentLayerProps(
    uiTokens);
  const { hierarchy: hierarchy_, styles } = hiddenFilter({
    hierarchy_: hierarchy,
    styles_,
    api,
    props: mergedProps
  });
  const propMergedStyles = mergeStyleProperties(
    mergedProps,
    styles,
    api.data,
    layerProps
  );
  const drawnComponent = drawComponent(
    componentName,
    propMergedStyles,
    hierarchy,
    invariants,
    { ...flatTokens, ...propTokens }
  );
  return renderComponent({
    currentLayer: hierarchy_,
    api,
    props: mergedProps,
    componentName: customMergedJSON?.metadata?.name || componentName,
    children: api.children,
    componentsMap,
    base: propMergedStyles,
    layerProps,
    internalIndex: props.internalIndex,
    root: true,
    componentTag,
    drawnComponent,
    runtime,
    tokens: flatTokens
  });
};
const ComponentWithTokens = ({
  children,
  base,
  layer,
  propTokens,
  runtime
}) => {
  const tokens = useTokenValues();
  if (runtime && // !['text', 'icon'].some((key) => layer.endsWith(key)) &&
  !layer.includes("jds_")) {
    return cloneElement(children, {
      style: Object.fromEntries(
        Object.entries(base[layer] || {}).map(([key, value]) => [
          key,
          fetchTokenValue(key, value, tokens)
        ])
      )
    });
  }
  if (tokens.brandVersion !== "jio-v2") {
    if (Object.keys(tokens).some((key) => key in base[layer])) {
      return /* @__PURE__ */ jsx(
        TokenProvider,
        {
          value: pickBy(base[layer], (v, k) => themeKeys.includes(k)),
          children
        }
      );
    }
    return children;
  }
  const colorKeys = [
    "appearance",
    "surface",
    "strokeSurface",
    "color",
    "background-color",
    "border-color",
    "fill"
  ];
  if (tokens?.["brandVersion"] !== "jio-v2" || (!base[layer] || !colorKeys.some((k) => base[layer]?.[k])) && !Object.keys(propTokens || {}).length || layer.endsWith("slot")) {
    return children;
  }
  const colorProperty = Object.keys(base[layer] || {}).find(
    (key) => key.endsWith("color") && !key.includes("border")
  );
  const borderColorProperty = Object.keys(base[layer] || {}).find(
    (key) => key.includes("border")
  );
  const colorToken = removeBraces(String(base[layer]?.[colorProperty]) || "");
  const borderColorToken = removeBraces(
    String(base[layer]?.[borderColorProperty]) || ""
  );
  const surface = colorToken?.split("_")?.[2];
  const strokeSurface = borderColorToken?.split("_")?.[2];
  return /* @__PURE__ */ jsx(
    TokenProvider,
    {
      value: {
        ...pickBy(base[layer], (v, k) => themeKeys.includes(k)),
        ...propTokens,
        surface: base[layer]?.surface?.toString() || surface || "ghost",
        strokeSurface: base[layer]?.strokeSurface?.toString() || strokeSurface || void 0
      },
      children
    }
  );
};
const renderComponent = ({
  currentLayer,
  api,
  props,
  componentName,
  children,
  componentsMap,
  base,
  layerProps,
  internalIndex,
  root,
  componentTag,
  drawnComponent,
  runtime,
  tokens
}) => {
  const isV2 = tokens?.["brandVersion"] === "jio-v2";
  if (typeof currentLayer === "string") {
    const CurrentComp = getCompFromKey(currentLayer, componentsMap);
    const { processData, processedEvents, processedA11y } = processDataAPI(
      api,
      currentLayer,
      props
    );
    const drawnClasses = drawnComponent.classes[currentLayer] ?? [];
    const drawnStyles = drawnComponent.styles;
    if (CurrentComp) {
      const processedConfigAPI = processConfigAPI(api?.config, props);
      const newProps = merge(
        processedConfigAPI,
        layerProps?.[currentLayer],
        processData,
        { events: processedEvents },
        processedA11y
      );
      const className = getLayerClass(componentName, currentLayer);
      const isAtomicLayer = isAtomic(currentLayer);
      const Component = /* @__PURE__ */ jsx(
        CurrentComp,
        {
          layer: currentLayer,
          "data-testid": getLayerTestId(componentName, currentLayer),
          _childrenProps: { api: children, props, componentsMap },
          disabled: props.disabled || layerProps?.[currentLayer]?.["disabled"],
          ...newProps,
          runtime: runtime && !currentLayer.includes("jds_"),
          ...newProps.events,
          isContainerFocusable: getIsContainerFocusable(api, currentLayer),
          className: isAtomic && isV2 ? classNames(
            className,
            ...drawnClasses,
            newProps.className
          ) : !Object.keys(base).length ? "" : className,
          style: root ? drawnStyles : void 0,
          internalIndex: internalIndex || 0,
          processedA11y
        },
        currentLayer
      );
      if (!isValidElement(Component))
        return null;
      if (!isAtomicLayer) {
        return /* @__PURE__ */ jsx(
          "div",
          {
            style: { display: "contents", ...root ? drawnStyles : {} },
            className,
            children: Component
          },
          currentLayer
        );
      }
      if (currentLayer.endsWith("slot")) {
        if (props?.[children?.[currentLayer]?.name])
          return Component;
        return null;
      }
      return /* @__PURE__ */ jsx(
        ComponentWithTokens,
        {
          base,
          layer: currentLayer,
          runtime,
          propTokens: pickBy(
            newProps,
            (v, k) => themeKeys.includes(k) && v !== "auto"
          ),
          children: Component
        },
        currentLayer
      );
    }
  } else if (typeof currentLayer === "object" && !Array.isArray(currentLayer)) {
    return Object.keys(currentLayer).map((layer) => {
      const drawnClasses = drawnComponent.classes[layer] ?? [];
      const drawnStyles = drawnComponent.styles;
      const CurrentComp = getCompFromKey(layer, componentsMap);
      const { processData, processedEvents, processedA11y } = processDataAPI(api, layer, props) || {};
      if (CurrentComp) {
        const processedConfigAPI = processConfigAPI(api?.config, props);
        const newProps = {
          ...processedConfigAPI,
          ...layerProps?.[layer],
          ...processData,
          ...processedEvents,
          ...processedA11y,
          ...{ style: root ? props.style : void 0 },
          componentTag: root ? componentTag : void 0,
          rootRef: root ? props.rootRef : void 0
        };
        const listName = api.data?.[layer]?.["value"]?.name;
        const arrayData = api.data?.[layer]?.["value"]?.type === "list" ? props[listName] : void 0;
        const className = getLayerClass(componentName, layer);
        return /* @__PURE__ */ jsx(
          ComponentWithTokens,
          {
            base,
            layer,
            runtime,
            propTokens: pickBy(
              newProps,
              (v, k) => themeKeys.includes(k) && v !== "auto"
            ),
            children: /* @__PURE__ */ jsx(
              CurrentComp,
              {
                "data-testid": getLayerTestId(componentName, layer),
                ...newProps,
                layer,
                runtime: runtime && !layer.includes("jds_"),
                className: classNames(
                  className,
                  !root ? "" : newProps.className,
                  ...isV2 ? drawnClasses : []
                ),
                isContainerFocusable: getIsContainerFocusable(api, layer),
                style: root ? { ...props.style ?? {}, ...drawnStyles } : void 0,
                events: processedEvents,
                disabled: props.disabled || layerProps?.[layer]?.["disabled"],
                internalIndex,
                processedA11y,
                children: arrayData ? arrayData?.map((valueItem, i) => {
                  return renderComponent({
                    currentLayer: currentLayer[layer],
                    api,
                    props: { ...props, ...valueItem, internalIndex: i },
                    componentName,
                    children,
                    componentsMap,
                    base,
                    layerProps,
                    internalIndex: valueItem.internalIndex || i,
                    drawnComponent,
                    runtime,
                    tokens
                  });
                }) : renderComponent({
                  currentLayer: currentLayer[layer],
                  api,
                  props: { ...props },
                  componentName,
                  children,
                  componentsMap,
                  base,
                  layerProps,
                  internalIndex,
                  drawnComponent,
                  runtime,
                  tokens
                })
              },
              layer
            )
          },
          layer
        );
      }
      return null;
    });
  } else if (typeof currentLayer === "object" && Array.isArray(currentLayer)) {
    return currentLayer.map((child) => {
      return renderComponent({
        currentLayer: child,
        api,
        props,
        componentName,
        children,
        componentsMap,
        base,
        layerProps,
        internalIndex,
        drawnComponent,
        runtime,
        tokens
      });
    });
  }
  return null;
};
const getCompFromKey = (obj, componentsMap) => {
  const layerName = getBaseLayerName(obj);
  if (componentsMap && componentsMap[layerName]) {
    try {
      return componentsMap[layerName]?.() || null;
    } catch (error) {
      return null;
    }
  }
  if (isAtomic(layerName))
    return atomsMap[layerName] || null;
  return null;
};
const excludedLayers = [
  "input",
  "container",
  "arc",
  "slider",
  "loader",
  "button_vector",
  "skeletonLoader"
];
const hasProps = (layerName = "", api, props, styles) => {
  if (excludedLayers.some((layer) => layerName.endsWith(layer)))
    return true;
  const apiLayers = api.data?.[layerName];
  const childlayers = api.children?.[layerName];
  if (!apiLayers && !childlayers && Object.values(apiLayers || {}).every(({ type }) => type === "boolean"))
    return true;
  const hasChildren = Boolean(props?.[childlayers?.name]);
  const hasData = Object.values(apiLayers || {}).some(
    ({ name }) => ![void 0, null, ""].includes(props[name]) || ![void 0, null, ""].includes(styles?.[layerName]?.[name]) || name.includes(".")
  );
  const hasBaseProps = Object.keys((styles || {})[layerName] || {}).filter(
    (key) => Object.values(apiLayers || {}).find(({ name }) => name === key)
  )?.length;
  if (!hasData && hasBaseProps)
    return true;
  if (!hasData && !(hasChildren && childlayers))
    return false;
  return true;
};
const hiddenFilter = ({
  hierarchy_,
  styles_,
  api,
  props
}) => {
  const hiddenLayers = [];
  const styles = Object.entries(styles_).reduce(
    (acc, [layerName, styleProps]) => {
      if (isHidden(styleProps.hidden) && !styleProps?.["transition"]) {
        hiddenLayers.push(layerName);
      } else {
        acc[layerName] = styleProps;
      }
      return acc;
    },
    {}
  );
  const hierarchy = filterHierarchy(
    hierarchy_,
    hiddenLayers,
    api,
    props,
    styles
  );
  return { hierarchy, styles };
};
const isHidden = (hidden) => {
  if (typeof hidden === "string") {
    return hidden.includes("true");
  }
  return Boolean(hidden);
};
const isLayerHidden = (layer, hiddenLayers) => {
  return hiddenLayers.includes(layer);
};
const filterHierarchy = (hierarchy, hiddenLayers, api, props, styles) => {
  if (typeof hierarchy === "string" && !isLayerHidden(hierarchy, hiddenLayers) && hasProps(hierarchy, api, props, styles)) {
    return hierarchy;
  } else if (typeof hierarchy === "object" && !Array.isArray(hierarchy)) {
    const end = Object.keys(hierarchy).filter((key) => {
      return !isLayerHidden(key, hiddenLayers) && hasProps(key, api, props);
    }).reduce((res, key) => {
      res[key] = filterHierarchy(
        hierarchy[key],
        hiddenLayers,
        api,
        props,
        styles
      );
      return res;
    }, {});
    return end;
  } else if (typeof hierarchy === "object" && Array.isArray(hierarchy)) {
    const res = [];
    hierarchy.forEach((key) => {
      res.push(filterHierarchy(key, hiddenLayers, api, props, styles));
    });
    return res.filter((r) => Object.keys(r).length).flat();
  }
  return {};
};
function getIsContainerFocusable(api, layer) {
  const clickEvent = api.events?.[layer]?.onClick;
  if (layer.includes("popup"))
    return false;
  if (layer.includes("button"))
    return true;
  if (!layer.includes("container"))
    return false;
  if (clickEvent) {
    const name = typeof clickEvent === "string" ? clickEvent : clickEvent.name;
    return !name.startsWith("_");
  }
}

const English$6 = {
	of: "of"
};
const Hindi$6 = {
	of: "का"
};
const Marathi$6 = {
	of: "च्या"
};
const Gujarati$6 = {
	of: "ના"
};
const Punjabi$6 = {
	of: "ਦੇ"
};
const Bengali$6 = {
	of: "এর"
};
const Tamil$6 = {
	of: "இன்"
};
const Telugu$6 = {
	of: "యొక్క"
};
const Kannada$6 = {
	of: "ನ"
};
const Assamese$6 = {
	of: "ৰ"
};
const Malayalam$6 = {
	of: "യുടെ"
};
const Oriya$6 = {
	of: "ର"
};
const of = {
	English: English$6,
	Hindi: Hindi$6,
	Marathi: Marathi$6,
	Gujarati: Gujarati$6,
	Punjabi: Punjabi$6,
	Bengali: Bengali$6,
	Tamil: Tamil$6,
	Telugu: Telugu$6,
	Kannada: Kannada$6,
	Assamese: Assamese$6,
	Malayalam: Malayalam$6,
	Oriya: Oriya$6
};

const ofData = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
  __proto__: null,
  Assamese: Assamese$6,
  Bengali: Bengali$6,
  English: English$6,
  Gujarati: Gujarati$6,
  Hindi: Hindi$6,
  Kannada: Kannada$6,
  Malayalam: Malayalam$6,
  Marathi: Marathi$6,
  Oriya: Oriya$6,
  Punjabi: Punjabi$6,
  Tamil: Tamil$6,
  Telugu: Telugu$6,
  default: of
}, Symbol.toStringTag, { value: 'Module' }));

const English$5 = {
	ConfirmButton: "Confirm"
};
const Hindi$5 = {
	ConfirmButton: "पुष्टि करें"
};
const Marathi$5 = {
	ConfirmButton: "पुष्टी"
};
const Gujarati$5 = {
	ConfirmButton: "પુષ્ટિ કરો"
};
const Punjabi$5 = {
	ConfirmButton: "ਪੁਸ਼ਟੀ ਕਰੋ"
};
const Bengali$5 = {
	ConfirmButton: "নিশ্চিত করুন"
};
const Tamil$5 = {
	ConfirmButton: "உறுதிப்படுத்தவும்"
};
const Telugu$5 = {
	ConfirmButton: "నిర్ధారించండి"
};
const Kannada$5 = {
	ConfirmButton: "ದೃಢೀಕರಿಸಿ"
};
const Assamese$5 = {
	ConfirmButton: "নিশ্চিত"
};
const Malayalam$5 = {
	ConfirmButton: "സ്ഥിരീകരിക്കുക"
};
const Oriya$5 = {
	ConfirmButton: "ନିଶ୍ଚିତ କରନ୍ତୁ |"
};
const confirmButtonData = {
	English: English$5,
	Hindi: Hindi$5,
	Marathi: Marathi$5,
	Gujarati: Gujarati$5,
	Punjabi: Punjabi$5,
	Bengali: Bengali$5,
	Tamil: Tamil$5,
	Telugu: Telugu$5,
	Kannada: Kannada$5,
	Assamese: Assamese$5,
	Malayalam: Malayalam$5,
	Oriya: Oriya$5
};

const as = "Assamese";
const bn = "Bengali";
const en = "English";
const gu = "Gujarati";
const hi = "Hindi";
const kn = "Kannada";
const ml = "Malayalam";
const mr = "Marathi";
const or = "Oriya";
const pa = "Punjabi";
const ta = "Tamil";
const te = "Telugu";
const localeLanguageData = {
	as: as,
	bn: bn,
	en: en,
	gu: gu,
	hi: hi,
	kn: kn,
	ml: ml,
	mr: mr,
	or: or,
	pa: pa,
	ta: ta,
	te: te
};

const English$4 = {
	zero: "0",
	one: "1",
	two: "2",
	three: "3",
	four: "4",
	five: "5",
	six: "6",
	seven: "7",
	eight: "8",
	nine: "9",
	ten: "10",
	eleven: "11",
	twelve: "12",
	thirteen: "13",
	fourteen: "14",
	fifteen: "15",
	sixteen: "16",
	seventeen: "17",
	eighteen: "18",
	nineteen: "19",
	twenty: "20",
	twenty_one: "21",
	twenty_two: "22",
	twenty_three: "23",
	twenty_four: "24",
	twenty_five: "25",
	twenty_six: "26",
	twenty_seven: "27",
	twenty_eight: "28",
	twenty_nine: "29",
	thirty: "30",
	thirty_one: "31"
};
const Hindi$4 = {
	zero: "०",
	one: "१",
	two: "२",
	three: "३",
	four: "४",
	five: "५",
	six: "६",
	seven: "७",
	eight: "८",
	nine: "९",
	ten: "१०",
	eleven: "११",
	twelve: "१२",
	thirteen: "१३",
	fourteen: "१४",
	fifteen: "१५",
	sixteen: "१६",
	seventeen: "१७",
	eighteen: "१८",
	nineteen: "१९",
	twenty: "२०",
	twenty_one: "२१",
	twenty_two: "२२",
	twenty_three: "२३",
	twenty_four: "२४",
	twenty_five: "२५",
	twenty_six: "२६",
	twenty_seven: "२७",
	twenty_eight: "२८",
	twenty_nine: "२९",
	thirty: "३०",
	thirty_one: "३१"
};
const Marathi$4 = {
	zero: "०",
	one: "१",
	two: "२",
	three: "३",
	four: "४",
	five: "५",
	six: "६",
	seven: "७",
	eight: "८",
	nine: "९",
	ten: "१०",
	eleven: "११",
	twelve: "१२",
	thirteen: "१३",
	fourteen: "१४",
	fifteen: "१५",
	sixteen: "१६",
	seventeen: "१७",
	eighteen: "१८",
	nineteen: "१९",
	twenty: "२०",
	twenty_one: "२१",
	twenty_two: "२२",
	twenty_three: "२३",
	twenty_four: "२४",
	twenty_five: "२५",
	twenty_six: "२६",
	twenty_seven: "२७",
	twenty_eight: "२८",
	twenty_nine: "२९",
	thirty: "३०",
	thirty_one: "३१"
};
const Gujarati$4 = {
	zero: "૦",
	one: "૧",
	two: "૨",
	three: "૩",
	four: "૪",
	five: "૫",
	six: "૬",
	seven: "૭",
	eight: "૮",
	nine: "૯",
	ten: "૧૦",
	eleven: "૧૧",
	twelve: "૧૨",
	thirteen: "૧૩",
	fourteen: "૧૪",
	fifteen: "૧૫",
	sixteen: "૧૬",
	seventeen: "૧૭",
	eighteen: "૧૮",
	nineteen: "૧૯",
	twenty: "૨૦",
	twenty_one: "૨૧",
	twenty_two: "૨૨",
	twenty_three: "૨૩",
	twenty_four: "૨૪",
	twenty_five: "૨૫",
	twenty_six: "૨૬",
	twenty_seven: "૨૭",
	twenty_eight: "૨૮",
	twenty_nine: "૨૯",
	thirty: "૩૦",
	thirty_one: "૩૧"
};
const Punjabi$4 = {
	zero: "੦",
	one: "੧",
	two: "੨",
	three: "੩",
	four: "੪",
	five: "੫",
	six: "੬",
	seven: "੭",
	eight: "੮",
	nine: "੯",
	ten: "੧੦",
	eleven: "੧੧",
	twelve: "੧੨",
	thirteen: "੧੩",
	fourteen: "੧੪",
	fifteen: "੧੫",
	sixteen: "੧੬",
	seventeen: "੧੭",
	eighteen: "੧੮",
	nineteen: "੧੯",
	twenty: "੨੦",
	twenty_one: "੨੧",
	twenty_two: "੨੨",
	twenty_three: "੨੩",
	twenty_four: "੨੪",
	twenty_five: "੨੫",
	twenty_six: "੨੬",
	twenty_seven: "੨੭",
	twenty_eight: "੨੮",
	twenty_nine: "੨੯",
	thirty: "੩੦",
	thirty_one: "੩੧"
};
const Bengali$4 = {
	zero: "০",
	one: "১",
	two: "২",
	three: "৩",
	four: "৪",
	five: "৫",
	six: "৬",
	seven: "৭",
	eight: "৮",
	nine: "৯",
	ten: "১০",
	eleven: "১১",
	twelve: "১২",
	thirteen: "১৩",
	fourteen: "১৪",
	fifteen: "১৫",
	sixteen: "১৬",
	seventeen: "১৭",
	eighteen: "১৮",
	nineteen: "১৯",
	twenty: "২০",
	twenty_one: "২১",
	twenty_two: "২২",
	twenty_three: "২৩",
	twenty_four: "২৪",
	twenty_five: "২৫",
	twenty_six: "২৬",
	twenty_seven: "২৭",
	twenty_eight: "২৮",
	twenty_nine: "২৯",
	thirty: "৩০",
	thirty_one: "৩১"
};
const Tamil$4 = {
	zero: "௦",
	one: "௧",
	two: "௨",
	three: "௩",
	four: "௪",
	five: "௫",
	six: "௬",
	seven: "௭",
	eight: "௮",
	nine: "௯",
	ten: "௧௦",
	eleven: "௧௧",
	twelve: "௧௨",
	thirteen: "௧௩",
	fourteen: "௧௪",
	fifteen: "௧௫",
	sixteen: "௧௬",
	seventeen: "௧௭",
	eighteen: "௧௮",
	nineteen: "௧௯",
	twenty: "௨௦",
	twenty_one: "௨௧",
	twenty_two: "௨௨",
	twenty_three: "௨௩",
	twenty_four: "௨௪",
	twenty_five: "௨௫",
	twenty_six: "௨௬",
	twenty_seven: "௨௭",
	twenty_eight: "௨௮",
	twenty_nine: "௨௯",
	thirty: "௩௦",
	thirty_one: "௩௧"
};
const Telugu$4 = {
	zero: "౦",
	one: "౧",
	two: "౨",
	three: "౩",
	four: "౪",
	five: "౫",
	six: "౬",
	seven: "౭",
	eight: "౮",
	nine: "౯",
	ten: "౧౦",
	eleven: "౧౧",
	twelve: "౧౨",
	thirteen: "౧౩",
	fourteen: "౧౪",
	fifteen: "౧౫",
	sixteen: "౧౬",
	seventeen: "౧౭",
	eighteen: "౧౮",
	nineteen: "౧౯",
	twenty: "౨౦",
	twenty_one: "౨౧",
	twenty_two: "౨౨",
	twenty_three: "౨౩",
	twenty_four: "౨౪",
	twenty_five: "౨౫",
	twenty_six: "౨౬",
	twenty_seven: "౨౭",
	twenty_eight: "౨౮",
	twenty_nine: "౨౯",
	thirty: "౩౦",
	thirty_one: "౩౧"
};
const Kannada$4 = {
	zero: "೦",
	one: "೧",
	two: "೨",
	three: "೩",
	four: "೪",
	five: "೫",
	six: "೬",
	seven: "೭",
	eight: "೮",
	nine: "೯",
	ten: "೧೦",
	eleven: "೧೧",
	twelve: "೧೨",
	thirteen: "೧೩",
	fourteen: "೧೪",
	fifteen: "೧೫",
	sixteen: "೧೬",
	seventeen: "೧೭",
	eighteen: "೧೮",
	nineteen: "೧೯",
	twenty: "೨೦",
	twenty_one: "೨೧",
	twenty_two: "೨೨",
	twenty_three: "೨೩",
	twenty_four: "೨೪",
	twenty_five: "೨೫",
	twenty_six: "೨೬",
	twenty_seven: "೨೭",
	twenty_eight: "೨೮",
	twenty_nine: "೨೯",
	thirty: "೩೦",
	thirty_one: "೩೧"
};
const Assamese$4 = {
	zero: "০",
	one: "১",
	two: "২",
	three: "৩",
	four: "৪",
	five: "৫",
	six: "৬",
	seven: "৭",
	eight: "৮",
	nine: "৯",
	ten: "১০",
	eleven: "১১",
	twelve: "১২",
	thirteen: "১৩",
	fourteen: "১৪",
	fifteen: "১৫",
	sixteen: "১৬",
	seventeen: "১৭",
	eighteen: "১৮",
	nineteen: "১৯",
	twenty: "২০",
	twenty_one: "২১",
	twenty_two: "২২",
	twenty_three: "২৩",
	twenty_four: "২৪",
	twenty_five: "২৫",
	twenty_six: "২৬",
	twenty_seven: "২৭",
	twenty_eight: "২৮",
	twenty_nine: "২৯",
	thirty: "৩০",
	thirty_one: "৩১"
};
const Malayalam$4 = {
	zero: "൦",
	one: "൧",
	two: "൨",
	three: "൩",
	four: "൪",
	five: "൫",
	six: "൬",
	seven: "൭",
	eight: "൮",
	nine: "൯",
	ten: "൧൦",
	eleven: "൧൧",
	twelve: "൧൨",
	thirteen: "൧൩",
	fourteen: "൧൪",
	fifteen: "൧൫",
	sixteen: "൧൬",
	seventeen: "൧൭",
	eighteen: "൧൮",
	nineteen: "൧൯",
	twenty: "൨൦",
	twenty_one: "൨൧",
	twenty_two: "൨൨",
	twenty_three: "൨൩",
	twenty_four: "൨൪",
	twenty_five: "൨൫",
	twenty_six: "൨൬",
	twenty_seven: "൨൭",
	twenty_eight: "൨൮",
	twenty_nine: "൨൯",
	thirty: "൩൦",
	thirty_one: "൩൧"
};
const Oriya$4 = {
	zero: "୦",
	one: "୧",
	two: "୨",
	three: "୩",
	four: "୪",
	five: "୫",
	six: "୬",
	seven: "୭",
	eight: "୮",
	nine: "୯",
	ten: "୧୦",
	eleven: "୧୧",
	twelve: "୧୨",
	thirteen: "୧୩",
	fourteen: "୧୪",
	fifteen: "୧୫",
	sixteen: "୧୬",
	seventeen: "୧୭",
	eighteen: "୧୮",
	nineteen: "୧୯",
	twenty: "୨୦",
	twenty_one: "୨୧",
	twenty_two: "୨୨",
	twenty_three: "୨୩",
	twenty_four: "୨୪",
	twenty_five: "୨୫",
	twenty_six: "୨୬",
	twenty_seven: "୨୭",
	twenty_eight: "୨୮",
	twenty_nine: "୨୯",
	thirty: "୩୦",
	thirty_one: "୩୧"
};
const monthDatesData = {
	English: English$4,
	Hindi: Hindi$4,
	Marathi: Marathi$4,
	Gujarati: Gujarati$4,
	Punjabi: Punjabi$4,
	Bengali: Bengali$4,
	Tamil: Tamil$4,
	Telugu: Telugu$4,
	Kannada: Kannada$4,
	Assamese: Assamese$4,
	Malayalam: Malayalam$4,
	Oriya: Oriya$4
};

const English$3 = {
	January: "January",
	February: "February",
	March: "March",
	April: "April",
	May: "May",
	June: "June",
	July: "July",
	August: "August",
	September: "September",
	October: "October",
	November: "November",
	December: "December"
};
const Hindi$3 = {
	January: "जनवरी",
	February: "फरवरी",
	March: "मार्च",
	April: "अप्रैल",
	May: "मई",
	June: "जून",
	July: "जुलाई",
	August: "अगस्त",
	September: "सितंबर",
	October: "अक्टूबर",
	November: "नवंबर",
	December: "दिसंबर"
};
const Marathi$3 = {
	January: "जानेवारी",
	February: "फेब्रुवारी",
	March: "मार्च",
	April: "एप्रिल",
	May: "मे",
	June: "जून",
	July: "जुलै",
	August: "ऑगस्ट",
	September: "सप्टेंबर",
	October: "ऑक्टोबर",
	November: "नोव्हेंबर",
	December: "डिसेंबर"
};
const Gujarati$3 = {
	January: "જાન્યુઆરી",
	February: "ફેબ્રુઆરી",
	March: "માર્ચ",
	April: "એપ્રિલ",
	May: "મે",
	June: "જૂન",
	July: "જુલાઈ",
	August: "ઑગસ્ટ",
	September: "સપ્ટેમ્બર",
	October: "ઓક્ટોબર",
	November: "નવેમ્બર",
	December: "ડિસેમ્બર"
};
const Punjabi$3 = {
	January: "ਜਨਵਰੀ",
	February: "ਫਰਵਰੀ",
	March: "ਮਾਰਚ",
	April: "ਅਪ੍ਰੈਲ",
	May: "ਮਈ",
	June: "ਜੂਨ",
	July: "ਜੁਲਾਈ",
	August: "ਅਗਸਤ",
	September: "ਸਤੰਬਰ",
	October: "ਅਕਤੂਬਰ",
	November: "ਨਵੰਬਰ",
	December: "ਦਸੰਬਰ"
};
const Bengali$3 = {
	January: "জানুয়ারি",
	February: "ফেব্রুয়ারি",
	March: "মার্চ",
	April: "এপ্রিল",
	May: "মে",
	June: "জুন",
	July: "জুলাই",
	August: "অগাস্ট",
	September: "সেপ্টেম্বর",
	October: "অক্টোবর",
	November: "নভেম্বর",
	December: "ডিসেম্বর"
};
const Tamil$3 = {
	January: "ஜனவரி",
	February: "பிப்ரவரி",
	March: "மார்ச்",
	April: "ஏப்ரல்",
	May: "மே",
	June: "ஜூன்",
	July: "ஜூலை",
	August: "ஆகஸ்டு",
	September: "செப்டம்பர்",
	October: "அக்டோபர்",
	November: "நவம்பர்",
	December: "டிசம்பர்"
};
const Telugu$3 = {
	January: "జనవరి",
	February: "ఫిబ్రవరి",
	March: "మార్చి",
	April: "ఏప్రిల్",
	May: "మే",
	June: "జూన్",
	July: "జులై",
	August: "ఆగష్టు",
	September: "సెప్టెంబర్",
	October: "అక్టోబర్",
	November: "నవంబర్",
	December: "డిసెంబర్"
};
const Kannada$3 = {
	January: "ಜನವರಿ",
	February: "ಫೆಬ್ರವರಿ",
	March: "ಮಾರ್ಚ್",
	April: "ಏಪ್ರಿಲ್",
	May: "ಮೇ",
	June: "ಜೂನ್",
	July: "ಜುಲೈ",
	August: "ಆಗಸ್ಟ್",
	September: "ಸೆಪ್ಟೆಂಬರ್",
	October: "ಅಕ್ಟೋಬರ್",
	November: "ನವೆಂಬರ್",
	December: "ಡಿಸೆಂಬರ್"
};
const Assamese$3 = {
	January: "জানুৱাৰী",
	February: "ফেব্ৰুৱাৰী",
	March: "মাৰ্চ",
	April: "এপ্ৰিল",
	May: "মে",
	June: "জুন",
	July: "জুলাই",
	August: "আগষ্ট",
	September: "ছেপ্টেম্বৰ",
	October: "অক্টোবৰ",
	November: "নৱেম্বৰ",
	December: "ডিচেম্বৰ"
};
const Malayalam$3 = {
	January: "ജനുവരി",
	February: "ഫെബ്രുവരി",
	March: "മാർച്ച്",
	April: "ഏപ്രിൽ",
	May: "മേയ്",
	June: "ജൂൺ",
	July: "ജൂലൈ",
	August: "ഓഗസ്റ്റ്",
	September: "സെപ്റ്റംബർ",
	October: "ഒക്ടോബർ",
	November: "നവംബർ",
	December: "ഡിസംബർ"
};
const Oriya$3 = {
	January: "ଜାନୁଆରୀ",
	February: "ଫେବୃୟାରୀ",
	March: "ମାର୍ଚ୍",
	April: "ଏପ୍ରିଲ",
	May: "ମେ",
	June: "ଜୁନ",
	July: "ଜୁଲାଇ",
	August: "ଅଗଷ୍ଟ",
	September: "ସେପ୍ଟେମ୍ବର",
	October: "ଅକ୍ଟୋବର",
	November: "ନଭେମ୍ବର",
	December: "ଡିସେମ୍ବର"
};
const monthNamesData = {
	English: English$3,
	Hindi: Hindi$3,
	Marathi: Marathi$3,
	Gujarati: Gujarati$3,
	Punjabi: Punjabi$3,
	Bengali: Bengali$3,
	Tamil: Tamil$3,
	Telugu: Telugu$3,
	Kannada: Kannada$3,
	Assamese: Assamese$3,
	Malayalam: Malayalam$3,
	Oriya: Oriya$3
};

const English$2 = {
	zero: "0",
	one: "1",
	two: "2",
	three: "3",
	four: "4",
	five: "5",
	six: "6",
	seven: "7",
	eight: "8",
	nine: "9"
};
const Hindi$2 = {
	zero: "०",
	one: "१",
	two: "२",
	three: "३",
	four: "४",
	five: "५",
	six: "६",
	seven: "७",
	eight: "८",
	nine: "९"
};
const Marathi$2 = {
	zero: "०",
	one: "१",
	two: "२",
	three: "३",
	four: "४",
	five: "५",
	six: "६",
	seven: "७",
	eight: "८",
	nine: "९"
};
const Gujarati$2 = {
	zero: "૦",
	one: "૧",
	two: "૨",
	three: "૩",
	four: "૪",
	five: "૫",
	six: "૬",
	seven: "૭",
	eight: "૮",
	nine: "૯"
};
const Punjabi$2 = {
	zero: "੦",
	one: "੧",
	two: "੨",
	three: "੩",
	four: "੪",
	five: "੫",
	six: "੬",
	seven: "੭",
	eight: "੮",
	nine: "੯"
};
const Bengali$2 = {
	zero: "০",
	one: "১",
	two: "২",
	three: "৩",
	four: "৪",
	five: "৫",
	six: "৬",
	seven: "৭",
	eight: "৮",
	nine: "৯"
};
const Tamil$2 = {
	zero: "௦",
	one: "௧",
	two: "௨",
	three: "௩",
	four: "௪",
	five: "௫",
	six: "௬",
	seven: "௭",
	eight: "௮",
	nine: "௯"
};
const Telugu$2 = {
	zero: "౦",
	one: "౧",
	two: "౨",
	three: "౩",
	four: "౪",
	five: "౫",
	six: "౬",
	seven: "౭",
	eight: "౮",
	nine: "౯"
};
const Kannada$2 = {
	zero: "೦",
	one: "೧",
	two: "೨",
	three: "೩",
	four: "೪",
	five: "೫",
	six: "೬",
	seven: "೭",
	eight: "೮",
	nine: "೯"
};
const Assamese$2 = {
	zero: "০",
	one: "১",
	two: "২",
	three: "৩",
	four: "৪",
	five: "৫",
	six: "৬",
	seven: "৭",
	eight: "৮",
	nine: "৯"
};
const Malayalam$2 = {
	zero: "൦",
	one: "൧",
	two: "൨",
	three: "൩",
	four: "൪",
	five: "൫",
	six: "൬",
	seven: "൭",
	eight: "൮",
	nine: "൯"
};
const Oriya$2 = {
	zero: "୦",
	one: "୧",
	two: "୨",
	three: "୩",
	four: "୪",
	five: "୫",
	six: "୬",
	seven: "୭",
	eight: "୮",
	nine: "୯"
};
const numberData = {
	English: English$2,
	Hindi: Hindi$2,
	Marathi: Marathi$2,
	Gujarati: Gujarati$2,
	Punjabi: Punjabi$2,
	Bengali: Bengali$2,
	Tamil: Tamil$2,
	Telugu: Telugu$2,
	Kannada: Kannada$2,
	Assamese: Assamese$2,
	Malayalam: Malayalam$2,
	Oriya: Oriya$2
};

const English$1 = {
	Sunday: "S",
	Monday: "M",
	Tuesday: "T",
	Wednesday: "W",
	Thursday: "T",
	Friday: "F",
	Saturday: "S"
};
const Hindi$1 = {
	Sunday: "र",
	Monday: "सो",
	Tuesday: "मं",
	Wednesday: "बु",
	Thursday: "गु",
	Friday: "शु",
	Saturday: "श"
};
const Marathi$1 = {
	Sunday: "र",
	Monday: "सो",
	Tuesday: "मं",
	Wednesday: "बु",
	Thursday: "गु",
	Friday: "शु",
	Saturday: "श"
};
const Gujarati$1 = {
	Sunday: "ર",
	Monday: "સો",
	Tuesday: "મં",
	Wednesday: "બુ",
	Thursday: "ગુ",
	Friday: "શુ",
	Saturday: "શ"
};
const Punjabi$1 = {
	Sunday: "ਐ",
	Monday: "ਸੋ",
	Tuesday: "ਮੰ",
	Wednesday: "ਬੁ",
	Thursday: "ਵੀ",
	Friday: "ਸ਼ੁ",
	Saturday: "ਸ਼"
};
const Bengali$1 = {
	Sunday: "র",
	Monday: "সো",
	Tuesday: "মং",
	Wednesday: "বু",
	Thursday: "বৃ",
	Friday: "শু",
	Saturday: "শ"
};
const Tamil$1 = {
	Sunday: "ஞா",
	Monday: "தி",
	Tuesday: "செ",
	Wednesday: "பு",
	Thursday: "வி",
	Friday: "வெ",
	Saturday: "ச"
};
const Telugu$1 = {
	Sunday: "ఆ",
	Monday: "సో",
	Tuesday: "మం",
	Wednesday: "బు",
	Thursday: "గు",
	Friday: "శు",
	Saturday: "శ"
};
const Kannada$1 = {
	Sunday: "ಭಾ",
	Monday: "ಸೋ",
	Tuesday: "ಮಂ",
	Wednesday: "ಬು",
	Thursday: "ಗು",
	Friday: "ಶು",
	Saturday: "ಶ"
};
const Assamese$1 = {
	Sunday: "ৰ",
	Monday: "সো",
	Tuesday: "মং",
	Wednesday: "বু",
	Thursday: "বৃ",
	Friday: "শু",
	Saturday: "শ"
};
const Malayalam$1 = {
	Sunday: "ഞാ",
	Monday: "തി",
	Tuesday: "ചൊ",
	Wednesday: "ബു",
	Thursday: "വ്യ",
	Friday: "വെ",
	Saturday: "ശ"
};
const Oriya$1 = {
	Sunday: "ର",
	Monday: "ସୋ",
	Tuesday: "ମଂ",
	Wednesday: "ବୁ",
	Thursday: "ବି",
	Friday: "ଶୁ",
	Saturday: "ଶ"
};
const weekdayInitialsData = {
	English: English$1,
	Hindi: Hindi$1,
	Marathi: Marathi$1,
	Gujarati: Gujarati$1,
	Punjabi: Punjabi$1,
	Bengali: Bengali$1,
	Tamil: Tamil$1,
	Telugu: Telugu$1,
	Kannada: Kannada$1,
	Assamese: Assamese$1,
	Malayalam: Malayalam$1,
	Oriya: Oriya$1
};

const English = {
	Sunday: "Sunday",
	Monday: "Monday",
	Tuesday: "Tuesday",
	Wednesday: "Wednesday",
	Thursday: "Thursday",
	Friday: "Friday",
	Saturday: "Saturday"
};
const Hindi = {
	Sunday: "रविवार",
	Monday: "सोमवार",
	Tuesday: "मंगलवार",
	Wednesday: "बुधवार",
	Thursday: "गुरुवार",
	Friday: "शुक्रवार",
	Saturday: "शनिवार"
};
const Marathi = {
	Sunday: "रविवार",
	Monday: "सोमवार",
	Tuesday: "मंगळवार",
	Wednesday: "बुधवार",
	Thursday: "गुरुवार",
	Friday: "शुक्रवार",
	Saturday: "शनिवार"
};
const Gujarati = {
	Sunday: "રવિવાર",
	Monday: "સોમવાર",
	Tuesday: "મંગળવાર",
	Wednesday: "બુધવાર",
	Thursday: "ગુરુવાર",
	Friday: "શુક્રવાર",
	Saturday: "શનિવાર"
};
const Punjabi = {
	Sunday: "ਐਤਵਾਰ",
	Monday: "ਸੋਮਵਾਰ",
	Tuesday: "ਮੰਗਲਵਾਰ",
	Wednesday: "ਬੁੱਧਵਾਰ",
	Thursday: "ਵੀਰਵਾਰ",
	Friday: "ਸ਼ੁੱਕਰਵਾਰ",
	Saturday: "ਸ਼ਨਿਵਾਰ"
};
const Bengali = {
	Sunday: "রবিবার",
	Monday: "সোমবার",
	Tuesday: "মঙ্গলবার",
	Wednesday: "বুধবার",
	Thursday: "বৃহস্পতিবার",
	Friday: "শুক্রবার",
	Saturday: "শনিবার"
};
const Tamil = {
	Sunday: "ஞாயிறு",
	Monday: "திங்கள்",
	Tuesday: "செவ்வாய்",
	Wednesday: "புதன்",
	Thursday: "வியாழன்",
	Friday: "வெள்ளி",
	Saturday: "சனிக்கிழமை"
};
const Telugu = {
	Sunday: "ఆదివారం",
	Monday: "సోమవారం",
	Tuesday: "మంగళవారం",
	Wednesday: "బుధవారం",
	Thursday: "గురువారం",
	Friday: "శుక్రవారం",
	Saturday: "శనివారం"
};
const Kannada = {
	Sunday: "ಭಾನುವಾರ",
	Monday: "ಸೋಮವಾರ",
	Tuesday: "ಮಂಗಳವಾರ",
	Wednesday: "ಬುಧವಾರ",
	Thursday: "ಗುರುವಾರ",
	Friday: "ಶುಕ್ರವಾರ",
	Saturday: "ಶನಿವಾರ"
};
const Assamese = {
	Sunday: "ভানুৱার",
	Monday: "সোমবাৰ",
	Tuesday: "মঙ্গলবাৰ",
	Wednesday: "বুধবাৰ",
	Thursday: "বৃহস্পতিবাৰ",
	Friday: "শুক্ৰবাৰ",
	Saturday: "শনিবাৰ"
};
const Malayalam = {
	Sunday: "ഞായറാഴ്ച",
	Monday: "തിങ്കളാഴ്ച",
	Tuesday: "ചൊവ്വാഴ്ച",
	Wednesday: "ബുധനാഴ്ച",
	Thursday: "വ്യാഴാഴ്ച",
	Friday: "വെള്ളിയാഴ്ച",
	Saturday: "ശനിയാഴ്ച"
};
const Oriya = {
	Sunday: "ରବିବାର",
	Monday: "ସୋମବାର",
	Tuesday: "ମଙ୍ଗଳବାର",
	Wednesday: "ବୁଧବାର",
	Thursday: "ବୃହସ୍ପତିବାର",
	Friday: "ଶୁକ୍ରବାର",
	Saturday: "ଶନିବାର"
};
const weekdayNamesData = {
	English: English,
	Hindi: Hindi,
	Marathi: Marathi,
	Gujarati: Gujarati,
	Punjabi: Punjabi,
	Bengali: Bengali,
	Tamil: Tamil,
	Telugu: Telugu,
	Kannada: Kannada,
	Assamese: Assamese,
	Malayalam: Malayalam,
	Oriya: Oriya
};

const LOCALE_LANGUAGE_MAP = localeLanguageData;
const MONTH_DATES = monthDatesData;
const NUMBERS = numberData;
const WEEKDAY_INITIALS = weekdayInitialsData;
const WEEKDAY_NAMES = weekdayNamesData;
const MONTH_NAMES = monthNamesData;
const CONFIRM_BUTTON = confirmButtonData;
const OF = ofData;
const weekdayKeys = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
const monthKeys = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
const monthDateKeys = [
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine",
  "ten",
  "eleven",
  "twelve",
  "thirteen",
  "fourteen",
  "fifteen",
  "sixteen",
  "seventeen",
  "eighteen",
  "nineteen",
  "twenty",
  "twenty_one",
  "twenty_two",
  "twenty_three",
  "twenty_four",
  "twenty_five",
  "twenty_six",
  "twenty_seven",
  "twenty_eight",
  "twenty_nine",
  "thirty",
  "thirty_one"
];
const numberKeys = [
  "zero",
  "one",
  "two",
  "three",
  "four",
  "five",
  "six",
  "seven",
  "eight",
  "nine"
];
function getLanguageFromLocale(locale) {
  return LOCALE_LANGUAGE_MAP[locale];
}
function getMonthDates(locale = "en") {
  const language = getLanguageFromLocale(locale);
  const dates = MONTH_DATES[language];
  return monthDateKeys.map((key) => dates[key]);
}
function getMonthNames(locale = "en") {
  const language = getLanguageFromLocale(locale);
  const names = MONTH_NAMES[language];
  return monthKeys.map((key) => names[key]);
}
function getNumbers(locale = "en") {
  const language = getLanguageFromLocale(locale);
  const numbers = NUMBERS[language];
  return numberKeys.map((key) => numbers[key]);
}
function getWeekdayInitials(locale = "en") {
  const language = getLanguageFromLocale(locale);
  const initials = WEEKDAY_INITIALS[language];
  return weekdayKeys.map((key) => initials[key]);
}
function getWeekdayNames(locale = "en") {
  const language = getLanguageFromLocale(locale);
  const names = WEEKDAY_NAMES[language];
  return weekdayKeys.map((key) => names[key]);
}
function getConfirmLabel(locale = "en") {
  const language = getLanguageFromLocale(locale);
  const labelObj = CONFIRM_BUTTON[language];
  return Object.values(labelObj)[0];
}
function getOf(locale = "en") {
  const language = getLanguageFromLocale(locale);
  const ofObj = OF[language];
  return Object.values(ofObj)[0];
}

const noop = () => {
};

const useRootRef = (cb, deps = []) => {
  const [element, setElement] = useState(null);
  const rootRef = useCallback(
    (element2) => {
      setElement(element2);
      cb?.(element2);
    },
    [...deps]
  );
  return { element, rootRef };
};

export { Animated, AnimatedContainer, Arc, Container, Icon, Image, Input, Link, Loader, Popup, SkeletonAnimatedLayer, Slider, Slot, Text, Textarea, Tip, TokenContext, TokenProvider, TrapFocus, availableIcons, clamp, createComponent, getConfirmLabel, getCustomJSON, getDefaultTokenValues, getLanguageFromLocale, getMonthDates, getMonthNames, getNumbers, getOf, getProgress, getSteppedValue, getWeekdayInitials, getWeekdayNames, isAtomic, noop, registerIcons, setDefaultTokenValues, themeKeys, useIcons, useRootRef, useToken, useTokenValues };
